// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: challenges.sql

package sqlc

import (
	"context"
)

const getChallengeByID = `-- name: GetChallengeByID :one
SELECT id, name, category, description, difficulty, authors, type, hidden, max_points, score_type, points, solves, host, port, attachments FROM challenges WHERE id = $1
`

// Retrieve a challenge by its ID
func (q *Queries) GetChallengeByID(ctx context.Context, id int32) (Challenge, error) {
	row := q.queryRow(ctx, q.getChallengeByIDStmt, getChallengeByID, id)
	var i Challenge
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Category,
		&i.Description,
		&i.Difficulty,
		&i.Authors,
		&i.Type,
		&i.Hidden,
		&i.MaxPoints,
		&i.ScoreType,
		&i.Points,
		&i.Solves,
		&i.Host,
		&i.Port,
		&i.Attachments,
	)
	return i, err
}

const getTagsByChallenge = `-- name: GetTagsByChallenge :many
SELECT name FROM tags WHERE chall_id = $1
`

// Retrieve all tags associated with a challenge
func (q *Queries) GetTagsByChallenge(ctx context.Context, challID int32) ([]string, error) {
	rows, err := q.query(ctx, q.getTagsByChallengeStmt, getTagsByChallenge, challID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isChallengeSolved = `-- name: IsChallengeSolved :one
SELECT EXISTS(
  SELECT 1
    FROM submissions
    JOIN users ON users.id = submissions.user_id
    JOIN teams ON users.team_id = teams.id
      AND teams.id = (SELECT team_id FROM users WHERE users.id = $2)
    WHERE users.role = 'Player'
      AND submissions.status = 'Correct'
      AND submissions.chall_id = $1
)
`

type IsChallengeSolvedParams struct {
	ChallID int32 `json:"chall_id"`
	ID      int32 `json:"id"`
}

// Check if a challenge is solved by a user's team
func (q *Queries) IsChallengeSolved(ctx context.Context, arg IsChallengeSolvedParams) (bool, error) {
	row := q.queryRow(ctx, q.isChallengeSolvedStmt, isChallengeSolved, arg.ChallID, arg.ID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
