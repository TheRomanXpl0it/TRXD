// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: challenges.sql

package sqlc

import (
	"context"

	"github.com/lib/pq"
)

const getChallengeByID = `-- name: GetChallengeByID :one
SELECT id, name, category, description, difficulty, authors, tags, type, hidden, max_points, score_type, points, solves, host, port FROM challenges WHERE id = $1
`

// Retrieve a challenge by its ID
func (q *Queries) GetChallengeByID(ctx context.Context, id int32) (Challenge, error) {
	row := q.queryRow(ctx, q.getChallengeByIDStmt, getChallengeByID, id)
	var i Challenge
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Category,
		&i.Description,
		&i.Difficulty,
		pq.Array(&i.Authors),
		pq.Array(&i.Tags),
		&i.Type,
		&i.Hidden,
		&i.MaxPoints,
		&i.ScoreType,
		&i.Points,
		&i.Solves,
		&i.Host,
		&i.Port,
	)
	return i, err
}

const getDockerConfigsByID = `-- name: GetDockerConfigsByID :one
SELECT
  image,
  compose,
  hash_domain,
  envs,
  COALESCE(NULLIF(lifetime, 0), (SELECT value::INTEGER FROM configs WHERE key='instance-lifetime')) AS lifetime,
  COALESCE(NULLIF(max_memory, 0), (SELECT value::INTEGER FROM configs WHERE key='instance-max-memory')) AS max_memory,
  COALESCE(NULLIF(max_cpu, ''), (SELECT value FROM configs WHERE key='instance-max-cpu')) AS max_cpu
FROM docker_configs
WHERE chall_id = $1
`

type GetDockerConfigsByIDRow struct {
	Image      string      `json:"image"`
	Compose    string      `json:"compose"`
	HashDomain bool        `json:"hash_domain"`
	Envs       string      `json:"envs"`
	Lifetime   interface{} `json:"lifetime"`
	MaxMemory  interface{} `json:"max_memory"`
	MaxCpu     interface{} `json:"max_cpu"`
}

// Retrieve Docker configurations by challenge ID
func (q *Queries) GetDockerConfigsByID(ctx context.Context, challID int32) (GetDockerConfigsByIDRow, error) {
	row := q.queryRow(ctx, q.getDockerConfigsByIDStmt, getDockerConfigsByID, challID)
	var i GetDockerConfigsByIDRow
	err := row.Scan(
		&i.Image,
		&i.Compose,
		&i.HashDomain,
		&i.Envs,
		&i.Lifetime,
		&i.MaxMemory,
		&i.MaxCpu,
	)
	return i, err
}

const getHiddenAndAttachments = `-- name: GetHiddenAndAttachments :one
SELECT
  c.hidden, 
  (ARRAY_AGG(a.hash || '/' || a.name) FILTER (WHERE a.name IS NOT NULL))::TEXT[] AS attachments
FROM challenges c
LEFT JOIN attachments a
  ON a.chall_id = c.id
WHERE c.id = $1
GROUP BY c.hidden
`

type GetHiddenAndAttachmentsRow struct {
	Hidden      bool     `json:"hidden"`
	Attachments []string `json:"attachments"`
}

// Checks if a challenge is hidden
func (q *Queries) GetHiddenAndAttachments(ctx context.Context, id int32) (GetHiddenAndAttachmentsRow, error) {
	row := q.queryRow(ctx, q.getHiddenAndAttachmentsStmt, getHiddenAndAttachments, id)
	var i GetHiddenAndAttachmentsRow
	err := row.Scan(&i.Hidden, pq.Array(&i.Attachments))
	return i, err
}
