// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const addTeamMember = `-- name: AddTeamMember :exec
UPDATE users SET team_id = $1 WHERE id = $2 AND team_id IS NULL
`

type AddTeamMemberParams struct {
	TeamID sql.NullInt32 `json:"team_id"`
	ID     int32         `json:"id"`
}

// Assign a user to a team
func (q *Queries) AddTeamMember(ctx context.Context, arg AddTeamMemberParams) error {
	_, err := q.exec(ctx, q.addTeamMemberStmt, addTeamMember, arg.TeamID, arg.ID)
	return err
}

const checkFlags = `-- name: CheckFlags :one
SELECT BOOL_OR(($1 = flag) OR (regex AND $1 ~ flag)) FROM flags WHERE chall_id = $2
`

type CheckFlagsParams struct {
	Flag    string `json:"flag"`
	ChallID int32  `json:"chall_id"`
}

// Check if a flag matches any flags for a challenge
func (q *Queries) CheckFlags(ctx context.Context, arg CheckFlagsParams) (bool, error) {
	row := q.queryRow(ctx, q.checkFlagsStmt, checkFlags, arg.Flag, arg.ChallID)
	var bool_or bool
	err := row.Scan(&bool_or)
	return bool_or, err
}

const createCategory = `-- name: CreateCategory :exec
INSERT INTO categories (name, icon) VALUES ($1, $2)
`

type CreateCategoryParams struct {
	Name string `json:"name"`
	Icon string `json:"icon"`
}

// Insert a new category
func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) error {
	_, err := q.exec(ctx, q.createCategoryStmt, createCategory, arg.Name, arg.Icon)
	return err
}

const createChallenge = `-- name: CreateChallenge :one
INSERT INTO challenges (name, category, description, type, max_points, score_type)
  VALUES ($1, $2, $3, $4, $5, $6) RETURNING id
`

type CreateChallengeParams struct {
	Name        string     `json:"name"`
	Category    string     `json:"category"`
	Description string     `json:"description"`
	Type        DeployType `json:"type"`
	MaxPoints   int32      `json:"max_points"`
	ScoreType   ScoreType  `json:"score_type"`
}

// Insert a new challenge
func (q *Queries) CreateChallenge(ctx context.Context, arg CreateChallengeParams) (int32, error) {
	row := q.queryRow(ctx, q.createChallengeStmt, createChallenge,
		arg.Name,
		arg.Category,
		arg.Description,
		arg.Type,
		arg.MaxPoints,
		arg.ScoreType,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createFlag = `-- name: CreateFlag :exec
INSERT INTO flags (flag, chall_id, regex) VALUES ($1, $2, $3)
`

type CreateFlagParams struct {
	Flag    string `json:"flag"`
	ChallID int32  `json:"chall_id"`
	Regex   bool   `json:"regex"`
}

// Insert a new flag for a challenge
func (q *Queries) CreateFlag(ctx context.Context, arg CreateFlagParams) error {
	_, err := q.exec(ctx, q.createFlagStmt, createFlag, arg.Flag, arg.ChallID, arg.Regex)
	return err
}

const createInstance = `-- name: CreateInstance :one
WITH info AS (
    SELECT generate_instance_remote(
      $1,
      $2,
      $4::BOOLEAN
    ) AS remote
  )
INSERT INTO instances (team_id, chall_id, expires_at, host, port)
  VALUES ($1, $2, $3,
    (SELECT (remote).host FROM info), (SELECT (remote).port FROM info))
RETURNING host, port
`

type CreateInstanceParams struct {
	TeamID     int32     `json:"team_id"`
	ChallID    int32     `json:"chall_id"`
	ExpiresAt  time.Time `json:"expires_at"`
	HashDomain bool      `json:"hash_domain"`
}

type CreateInstanceRow struct {
	Host string        `json:"host"`
	Port sql.NullInt32 `json:"port"`
}

// Creates a new instance for a team
func (q *Queries) CreateInstance(ctx context.Context, arg CreateInstanceParams) (CreateInstanceRow, error) {
	row := q.queryRow(ctx, q.createInstanceStmt, createInstance,
		arg.TeamID,
		arg.ChallID,
		arg.ExpiresAt,
		arg.HashDomain,
	)
	var i CreateInstanceRow
	err := row.Scan(&i.Host, &i.Port)
	return i, err
}

const createTag = `-- name: CreateTag :exec
INSERT INTO tags (chall_id, name) VALUES ($1, $2)
`

type CreateTagParams struct {
	ChallID int32  `json:"chall_id"`
	Name    string `json:"name"`
}

// Creates a named tag for a challenge
func (q *Queries) CreateTag(ctx context.Context, arg CreateTagParams) error {
	_, err := q.exec(ctx, q.createTagStmt, createTag, arg.ChallID, arg.Name)
	return err
}

const deleteCategory = `-- name: DeleteCategory :exec
DELETE FROM categories WHERE name = $1
`

// Delete a category and all associated challenges
func (q *Queries) DeleteCategory(ctx context.Context, name string) error {
	_, err := q.exec(ctx, q.deleteCategoryStmt, deleteCategory, name)
	return err
}

const deleteChallenge = `-- name: DeleteChallenge :exec
DELETE FROM challenges WHERE id = $1
`

// Delete a challenge and all associated flags
func (q *Queries) DeleteChallenge(ctx context.Context, id int32) error {
	_, err := q.exec(ctx, q.deleteChallengeStmt, deleteChallenge, id)
	return err
}

const deleteFlag = `-- name: DeleteFlag :exec
DELETE FROM flags WHERE chall_id = $1 AND flag = $2
`

type DeleteFlagParams struct {
	ChallID int32  `json:"chall_id"`
	Flag    string `json:"flag"`
}

// Delete a flag from a challenge
func (q *Queries) DeleteFlag(ctx context.Context, arg DeleteFlagParams) error {
	_, err := q.exec(ctx, q.deleteFlagStmt, deleteFlag, arg.ChallID, arg.Flag)
	return err
}

const deleteInstance = `-- name: DeleteInstance :exec
DELETE FROM instances
  WHERE team_id = $1 AND chall_id = $2
`

type DeleteInstanceParams struct {
	TeamID  int32 `json:"team_id"`
	ChallID int32 `json:"chall_id"`
}

// Delete an instance
func (q *Queries) DeleteInstance(ctx context.Context, arg DeleteInstanceParams) error {
	_, err := q.exec(ctx, q.deleteInstanceStmt, deleteInstance, arg.TeamID, arg.ChallID)
	return err
}

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM tags WHERE chall_id = $1 AND name = $2
`

type DeleteTagParams struct {
	ChallID int32  `json:"chall_id"`
	Name    string `json:"name"`
}

// Deletes a challenge tag by name
func (q *Queries) DeleteTag(ctx context.Context, arg DeleteTagParams) error {
	_, err := q.exec(ctx, q.deleteTagStmt, deleteTag, arg.ChallID, arg.Name)
	return err
}

const getAllChallengesInfo = `-- name: GetAllChallengesInfo :many
WITH tid AS (SELECT team_id FROM users WHERE users.id = $1)
SELECT
    c.id, c.name, c.category, c.description, c.difficulty, c.authors, c.type, c.hidden, c.max_points, c.score_type, c.points, c.solves, c.host, c.port, c.attachments,
    (ARRAY_AGG(t.name) FILTER (WHERE t.name IS NOT NULL))::TEXT[] AS tags,
    (s.first_blood IS NOT NULL)::BOOLEAN AS solved,
    COALESCE(s.first_blood, FALSE) AS first_blood,
    i.expires_at,
    i.host AS instance_host,
    i.port AS instance_port,
    i.docker_id
  FROM challenges c
  LEFT JOIN tags t ON t.chall_id = c.id
  LEFT JOIN (
      SELECT submissions.chall_id, submissions.first_blood
        FROM submissions
        JOIN users ON users.id = submissions.user_id
        WHERE users.team_id = (SELECT team_id FROM tid)
          AND users.role = 'Player'
          AND submissions.status = 'Correct') s
    ON s.chall_id = c.id
  LEFT JOIN instances i
    ON i.chall_id = c.id
      AND i.team_id = (SELECT team_id FROM tid)
  GROUP BY c.id, s.first_blood, i.expires_at, i.host, i.port, i.docker_id 
  ORDER BY c.id
`

type GetAllChallengesInfoRow struct {
	ID           int32          `json:"id"`
	Name         string         `json:"name"`
	Category     string         `json:"category"`
	Description  string         `json:"description"`
	Difficulty   string         `json:"difficulty"`
	Authors      string         `json:"authors"`
	Type         DeployType     `json:"type"`
	Hidden       bool           `json:"hidden"`
	MaxPoints    int32          `json:"max_points"`
	ScoreType    ScoreType      `json:"score_type"`
	Points       int32          `json:"points"`
	Solves       int32          `json:"solves"`
	Host         string         `json:"host"`
	Port         int32          `json:"port"`
	Attachments  string         `json:"attachments"`
	Tags         []string       `json:"tags"`
	Solved       bool           `json:"solved"`
	FirstBlood   bool           `json:"first_blood"`
	ExpiresAt    sql.NullTime   `json:"expires_at"`
	InstanceHost sql.NullString `json:"instance_host"`
	InstancePort sql.NullInt32  `json:"instance_port"`
	DockerID     sql.NullString `json:"docker_id"`
}

// Retrieve all challenges along with first blood status and instance info for a user
func (q *Queries) GetAllChallengesInfo(ctx context.Context, id int32) ([]GetAllChallengesInfoRow, error) {
	rows, err := q.query(ctx, q.getAllChallengesInfoStmt, getAllChallengesInfo, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllChallengesInfoRow
	for rows.Next() {
		var i GetAllChallengesInfoRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Category,
			&i.Description,
			&i.Difficulty,
			&i.Authors,
			&i.Type,
			&i.Hidden,
			&i.MaxPoints,
			&i.ScoreType,
			&i.Points,
			&i.Solves,
			&i.Host,
			&i.Port,
			&i.Attachments,
			pq.Array(&i.Tags),
			&i.Solved,
			&i.FirstBlood,
			&i.ExpiresAt,
			&i.InstanceHost,
			&i.InstancePort,
			&i.DockerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBadgesFromTeam = `-- name: GetBadgesFromTeam :many
SELECT badges.name, badges.description FROM badges
  JOIN teams ON teams.id = badges.team_id
  WHERE teams.id = $1
`

type GetBadgesFromTeamRow struct {
	Name        string `json:"name"`
	Description string `json:"description"`
}

// Retrieve all badges associated with a team
func (q *Queries) GetBadgesFromTeam(ctx context.Context, id int32) ([]GetBadgesFromTeamRow, error) {
	rows, err := q.query(ctx, q.getBadgesFromTeamStmt, getBadgesFromTeam, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBadgesFromTeamRow
	for rows.Next() {
		var i GetBadgesFromTeamRow
		if err := rows.Scan(&i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategories = `-- name: GetCategories :many
SELECT name, visible_challs, icon FROM categories ORDER BY name ASC
`

// Retrieve all categories and icons
func (q *Queries) GetCategories(ctx context.Context) ([]Category, error) {
	rows, err := q.query(ctx, q.getCategoriesStmt, getCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(&i.Name, &i.VisibleChalls, &i.Icon); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategory = `-- name: GetCategory :one
SELECT name, visible_challs, icon FROM categories WHERE name = $1
`

// fetch category by name
func (q *Queries) GetCategory(ctx context.Context, name string) (Category, error) {
	row := q.queryRow(ctx, q.getCategoryStmt, getCategory, name)
	var i Category
	err := row.Scan(&i.Name, &i.VisibleChalls, &i.Icon)
	return i, err
}

const getChallDockerConfig = `-- name: GetChallDockerConfig :one
SELECT chall_id, image, compose, hash_domain, lifetime, envs, max_memory, max_cpu FROM docker_configs WHERE chall_id = $1
`

func (q *Queries) GetChallDockerConfig(ctx context.Context, challID int32) (DockerConfig, error) {
	row := q.queryRow(ctx, q.getChallDockerConfigStmt, getChallDockerConfig, challID)
	var i DockerConfig
	err := row.Scan(
		&i.ChallID,
		&i.Image,
		&i.Compose,
		&i.HashDomain,
		&i.Lifetime,
		&i.Envs,
		&i.MaxMemory,
		&i.MaxCpu,
	)
	return i, err
}

const getChallengeSolves = `-- name: GetChallengeSolves :many
SELECT teams.id, teams.name, submissions.timestamp
  FROM submissions
  JOIN users ON users.id = submissions.user_id
  JOIN teams ON users.team_id = teams.id
  WHERE users.role = 'Player'
    AND submissions.chall_id = $1
    AND submissions.status = 'Correct'
  ORDER BY submissions.timestamp ASC
`

type GetChallengeSolvesRow struct {
	ID        int32     `json:"id"`
	Name      string    `json:"name"`
	Timestamp time.Time `json:"timestamp"`
}

// Retrieve all teams that solved a challenge
func (q *Queries) GetChallengeSolves(ctx context.Context, challID int32) ([]GetChallengeSolvesRow, error) {
	rows, err := q.query(ctx, q.getChallengeSolvesStmt, getChallengeSolves, challID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChallengeSolvesRow
	for rows.Next() {
		var i GetChallengeSolvesRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Timestamp); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConfigs = `-- name: GetConfigs :many
SELECT key, type, value, description FROM configs ORDER BY key
`

// Fetches all configuration settings
func (q *Queries) GetConfigs(ctx context.Context) ([]Config, error) {
	rows, err := q.query(ctx, q.getConfigsStmt, getConfigs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Config
	for rows.Next() {
		var i Config
		if err := rows.Scan(
			&i.Key,
			&i.Type,
			&i.Value,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlagsByChallenge = `-- name: GetFlagsByChallenge :many
SELECT flag, regex FROM flags WHERE chall_id = $1
`

type GetFlagsByChallengeRow struct {
	Flag  string `json:"flag"`
	Regex bool   `json:"regex"`
}

// Retrieve all flags associated with a challenge
func (q *Queries) GetFlagsByChallenge(ctx context.Context, challID int32) ([]GetFlagsByChallengeRow, error) {
	rows, err := q.query(ctx, q.getFlagsByChallengeStmt, getFlagsByChallenge, challID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFlagsByChallengeRow
	for rows.Next() {
		var i GetFlagsByChallengeRow
		if err := rows.Scan(&i.Flag, &i.Regex); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInstance = `-- name: GetInstance :one
SELECT team_id, chall_id, expires_at, host, port, docker_id FROM instances WHERE chall_id = $1 AND team_id = $2
`

type GetInstanceParams struct {
	ChallID int32 `json:"chall_id"`
	TeamID  int32 `json:"team_id"`
}

// Gets an instance by ID
func (q *Queries) GetInstance(ctx context.Context, arg GetInstanceParams) (Instance, error) {
	row := q.queryRow(ctx, q.getInstanceStmt, getInstance, arg.ChallID, arg.TeamID)
	var i Instance
	err := row.Scan(
		&i.TeamID,
		&i.ChallID,
		&i.ExpiresAt,
		&i.Host,
		&i.Port,
		&i.DockerID,
	)
	return i, err
}

const getNextInstanceToDelete = `-- name: GetNextInstanceToDelete :one
SELECT team_id, chall_id, expires_at, docker_id
  FROM instances
  WHERE expires_at < NOW() + (
    (SELECT value
      FROM configs
      WHERE key='reclaim-instance-interval'
    ) || ' seconds')::INTERVAL
  ORDER BY expires_at ASC
  LIMIT 1
`

type GetNextInstanceToDeleteRow struct {
	TeamID    int32          `json:"team_id"`
	ChallID   int32          `json:"chall_id"`
	ExpiresAt time.Time      `json:"expires_at"`
	DockerID  sql.NullString `json:"docker_id"`
}

// Retrieves the next instance to delete
func (q *Queries) GetNextInstanceToDelete(ctx context.Context) (GetNextInstanceToDeleteRow, error) {
	row := q.queryRow(ctx, q.getNextInstanceToDeleteStmt, getNextInstanceToDelete)
	var i GetNextInstanceToDeleteRow
	err := row.Scan(
		&i.TeamID,
		&i.ChallID,
		&i.ExpiresAt,
		&i.DockerID,
	)
	return i, err
}

const getTeamMembers = `-- name: GetTeamMembers :many
SELECT id, name, role, score FROM users WHERE team_id = $1 ORDER BY id
`

type GetTeamMembersRow struct {
	ID    int32    `json:"id"`
	Name  string   `json:"name"`
	Role  UserRole `json:"role"`
	Score int32    `json:"score"`
}

// Retrieve all members of a team by team ID
func (q *Queries) GetTeamMembers(ctx context.Context, teamID sql.NullInt32) ([]GetTeamMembersRow, error) {
	rows, err := q.query(ctx, q.getTeamMembersStmt, getTeamMembers, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamMembersRow
	for rows.Next() {
		var i GetTeamMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Role,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamSolves = `-- name: GetTeamSolves :many
SELECT c.id, c.name, c.category, c.points, s.first_blood, s.timestamp, s.user_id
  FROM submissions s
  JOIN users u ON u.id = s.user_id
  JOIN teams t ON u.team_id = t.id
  JOIN challenges c ON c.id = s.chall_id
  WHERE u.role = 'Player'
    AND t.id = $1
    AND s.status = 'Correct'
  ORDER BY s.timestamp DESC
`

type GetTeamSolvesRow struct {
	ID         int32     `json:"id"`
	Name       string    `json:"name"`
	Category   string    `json:"category"`
	Points     int32     `json:"points"`
	FirstBlood bool      `json:"first_blood"`
	Timestamp  time.Time `json:"timestamp"`
	UserID     int32     `json:"user_id"`
}

// Retrieve all challenges solved by a team's members
func (q *Queries) GetTeamSolves(ctx context.Context, id int32) ([]GetTeamSolvesRow, error) {
	rows, err := q.query(ctx, q.getTeamSolvesStmt, getTeamSolves, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamSolvesRow
	for rows.Next() {
		var i GetTeamSolvesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Category,
			&i.Points,
			&i.FirstBlood,
			&i.Timestamp,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamsPreview = `-- name: GetTeamsPreview :many
SELECT
    t.id,
    t.name,
    t.score,
    t.country,
    t.image,
    COALESCE(
      JSON_AGG(
        JSON_BUILD_OBJECT(
          'name', b.name,
          'description', b.description
        )
      ) FILTER (WHERE b.name IS NOT NULL),
      '[]'
    ) AS badges
  FROM teams t
  LEFT JOIN badges b ON b.team_id = t.id
  GROUP BY t.id, t.name, t.score, t.country, t.image
  ORDER BY t.id
`

type GetTeamsPreviewRow struct {
	ID      int32          `json:"id"`
	Name    string         `json:"name"`
	Score   int32          `json:"score"`
	Country sql.NullString `json:"country"`
	Image   sql.NullString `json:"image"`
	Badges  interface{}    `json:"badges"`
}

// Retrieve all teams
func (q *Queries) GetTeamsPreview(ctx context.Context) ([]GetTeamsPreviewRow, error) {
	rows, err := q.query(ctx, q.getTeamsPreviewStmt, getTeamsPreview)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamsPreviewRow
	for rows.Next() {
		var i GetTeamsPreviewRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Score,
			&i.Country,
			&i.Image,
			&i.Badges,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamsScoreboard = `-- name: GetTeamsScoreboard :many
SELECT
    t.id,
    t.name,
    t.score,
    t.country,
    t.image,
    COALESCE(
      JSON_AGG(
        JSON_BUILD_OBJECT(
          'name', b.name,
          'description', b.description
        )
      ) FILTER (WHERE b.name IS NOT NULL),
      '[]'
    ) AS badges
  FROM teams t
  LEFT JOIN badges b ON b.team_id = t.id
  GROUP BY t.id, t.name, t.score, t.country, t.image
  ORDER BY t.score DESC
`

type GetTeamsScoreboardRow struct {
	ID      int32          `json:"id"`
	Name    string         `json:"name"`
	Score   int32          `json:"score"`
	Country sql.NullString `json:"country"`
	Image   sql.NullString `json:"image"`
	Badges  interface{}    `json:"badges"`
}

// Retrieve all teams
func (q *Queries) GetTeamsScoreboard(ctx context.Context) ([]GetTeamsScoreboardRow, error) {
	rows, err := q.query(ctx, q.getTeamsScoreboardStmt, getTeamsScoreboard)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamsScoreboardRow
	for rows.Next() {
		var i GetTeamsScoreboardRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Score,
			&i.Country,
			&i.Image,
			&i.Badges,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamsScoreboardGraph = `-- name: GetTeamsScoreboardGraph :many
SELECT t.id AS team_id, c.id AS chall_id, c.points, s.first_blood, s."timestamp" FROM (
	SELECT id, name, password_hash, password_salt, score, country, image, bio FROM teams t
        ORDER BY t.score DESC
        LIMIT CAST((SELECT value FROM configs WHERE key='scoreboard-top') AS INT)) AS t
  JOIN users u ON u.team_id = t.id
  JOIN submissions s ON s.user_id = u.id
  JOIN challenges c ON c.id = s.chall_id
  WHERE s.status = 'Correct'
	  AND u.role = 'Player'
  ORDER BY s."timestamp" ASC
`

type GetTeamsScoreboardGraphRow struct {
	TeamID     int32     `json:"team_id"`
	ChallID    int32     `json:"chall_id"`
	Points     int32     `json:"points"`
	FirstBlood bool      `json:"first_blood"`
	Timestamp  time.Time `json:"timestamp"`
}

// Get the top N teams along with their correct submissions and challenge points for scoreboard graphing
func (q *Queries) GetTeamsScoreboardGraph(ctx context.Context) ([]GetTeamsScoreboardGraphRow, error) {
	rows, err := q.query(ctx, q.getTeamsScoreboardGraphStmt, getTeamsScoreboardGraph)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamsScoreboardGraphRow
	for rows.Next() {
		var i GetTeamsScoreboardGraphRow
		if err := rows.Scan(
			&i.TeamID,
			&i.ChallID,
			&i.Points,
			&i.FirstBlood,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, name, email, password_hash, password_salt, created_at, score, role, team_id, country, image FROM users WHERE email = $1
`

// Retrieve a user by their email address
func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.queryRow(ctx, q.getUserByEmailStmt, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.PasswordSalt,
		&i.CreatedAt,
		&i.Score,
		&i.Role,
		&i.TeamID,
		&i.Country,
		&i.Image,
	)
	return i, err
}

const getUserSolves = `-- name: GetUserSolves :many
SELECT c.id, c.name, c.category, c.points, s.first_blood, s.timestamp
  FROM submissions s
  JOIN challenges c ON s.chall_id = c.id
  WHERE s.user_id = $1
    AND s.status = 'Correct'
`

type GetUserSolvesRow struct {
	ID         int32     `json:"id"`
	Name       string    `json:"name"`
	Category   string    `json:"category"`
	Points     int32     `json:"points"`
	FirstBlood bool      `json:"first_blood"`
	Timestamp  time.Time `json:"timestamp"`
}

// Retrieve all challenges solved by a user
func (q *Queries) GetUserSolves(ctx context.Context, userID int32) ([]GetUserSolvesRow, error) {
	rows, err := q.query(ctx, q.getUserSolvesStmt, getUserSolves, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserSolvesRow
	for rows.Next() {
		var i GetUserSolvesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Category,
			&i.Points,
			&i.FirstBlood,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersPreview = `-- name: GetUsersPreview :many
SELECT id, name, email, role, score, country, image
  FROM users
  ORDER BY id ASC
`

type GetUsersPreviewRow struct {
	ID      int32          `json:"id"`
	Name    string         `json:"name"`
	Email   string         `json:"email"`
	Role    UserRole       `json:"role"`
	Score   int32          `json:"score"`
	Country sql.NullString `json:"country"`
	Image   sql.NullString `json:"image"`
}

// Retrieve all users
func (q *Queries) GetUsersPreview(ctx context.Context) ([]GetUsersPreviewRow, error) {
	rows, err := q.query(ctx, q.getUsersPreviewStmt, getUsersPreview)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersPreviewRow
	for rows.Next() {
		var i GetUsersPreviewRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Role,
			&i.Score,
			&i.Country,
			&i.Image,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const registerTeam = `-- name: RegisterTeam :exec
WITH locked_user AS (
    SELECT id FROM users
    WHERE id = $1 AND team_id IS NULL
    FOR UPDATE
  ),
  new_team AS (
    INSERT INTO teams (name, password_hash, password_salt)
    SELECT $2, $3, $4
    FROM locked_user
    RETURNING id, name, password_hash, password_salt, score, country, image, bio
  )
UPDATE users
  SET team_id = new_team.id
  FROM new_team
  WHERE users.id = $1
`

type RegisterTeamParams struct {
	ID           int32  `json:"id"`
	Name         string `json:"name"`
	PasswordHash string `json:"password_hash"`
	PasswordSalt string `json:"password_salt"`
}

// Insert a new team and add the founder user to the team
func (q *Queries) RegisterTeam(ctx context.Context, arg RegisterTeamParams) error {
	_, err := q.exec(ctx, q.registerTeamStmt, registerTeam,
		arg.ID,
		arg.Name,
		arg.PasswordHash,
		arg.PasswordSalt,
	)
	return err
}

const registerUser = `-- name: RegisterUser :one
INSERT INTO users (name, email, password_hash, password_salt, role) VALUES ($1, $2, $3, $4, $5) RETURNING id, name, email, password_hash, password_salt, created_at, score, role, team_id, country, image
`

type RegisterUserParams struct {
	Name         string   `json:"name"`
	Email        string   `json:"email"`
	PasswordHash string   `json:"password_hash"`
	PasswordSalt string   `json:"password_salt"`
	Role         UserRole `json:"role"`
}

// Insert a new user and return the created user
func (q *Queries) RegisterUser(ctx context.Context, arg RegisterUserParams) (User, error) {
	row := q.queryRow(ctx, q.registerUserStmt, registerUser,
		arg.Name,
		arg.Email,
		arg.PasswordHash,
		arg.PasswordSalt,
		arg.Role,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.PasswordSalt,
		&i.CreatedAt,
		&i.Score,
		&i.Role,
		&i.TeamID,
		&i.Country,
		&i.Image,
	)
	return i, err
}

const resetTeamPassword = `-- name: ResetTeamPassword :exec
UPDATE teams SET password_hash = $2, password_salt = $3 WHERE id = $1
`

type ResetTeamPasswordParams struct {
	ID           int32  `json:"id"`
	PasswordHash string `json:"password_hash"`
	PasswordSalt string `json:"password_salt"`
}

// Reset a team's password to a new password
func (q *Queries) ResetTeamPassword(ctx context.Context, arg ResetTeamPasswordParams) error {
	_, err := q.exec(ctx, q.resetTeamPasswordStmt, resetTeamPassword, arg.ID, arg.PasswordHash, arg.PasswordSalt)
	return err
}

const resetUserPassword = `-- name: ResetUserPassword :exec
UPDATE users SET password_hash = $2, password_salt = $3 WHERE id = $1
`

type ResetUserPasswordParams struct {
	ID           int32  `json:"id"`
	PasswordHash string `json:"password_hash"`
	PasswordSalt string `json:"password_salt"`
}

// Reset a user's password to a new password
func (q *Queries) ResetUserPassword(ctx context.Context, arg ResetUserPasswordParams) error {
	_, err := q.exec(ctx, q.resetUserPasswordStmt, resetUserPassword, arg.ID, arg.PasswordHash, arg.PasswordSalt)
	return err
}

const submit = `-- name: Submit :one
WITH challenge AS (
    SELECT challenges.id FROM challenges
    WHERE challenges.id = $2 FOR UPDATE
  )
INSERT INTO submissions (user_id, chall_id, status, flag)
  VALUES ($1, (SELECT id FROM challenge), $4, $3)
  RETURNING status, first_blood
`

type SubmitParams struct {
	UserID int32            `json:"user_id"`
	ID     int32            `json:"id"`
	Flag   string           `json:"flag"`
	Status SubmissionStatus `json:"status"`
}

type SubmitRow struct {
	Status     SubmissionStatus `json:"status"`
	FirstBlood bool             `json:"first_blood"`
}

// Insert a new submission
func (q *Queries) Submit(ctx context.Context, arg SubmitParams) (SubmitRow, error) {
	row := q.queryRow(ctx, q.submitStmt, submit,
		arg.UserID,
		arg.ID,
		arg.Flag,
		arg.Status,
	)
	var i SubmitRow
	err := row.Scan(&i.Status, &i.FirstBlood)
	return i, err
}

const updateCategoryIcon = `-- name: UpdateCategoryIcon :exec
UPDATE categories SET icon = $2 WHERE name = $1
`

type UpdateCategoryIconParams struct {
	Name string `json:"name"`
	Icon string `json:"icon"`
}

// update category icon by name
func (q *Queries) UpdateCategoryIcon(ctx context.Context, arg UpdateCategoryIconParams) error {
	_, err := q.exec(ctx, q.updateCategoryIconStmt, updateCategoryIcon, arg.Name, arg.Icon)
	return err
}

const updateChallenge = `-- name: UpdateChallenge :exec
UPDATE challenges
SET
  name = COALESCE($1, name),
  category = COALESCE($2, category),
  description = COALESCE($3, description),
  difficulty = COALESCE($4, difficulty),
  authors = COALESCE($5, authors),
  type = COALESCE($6, type),
  hidden = COALESCE($7, hidden),
  max_points = COALESCE($8, max_points),
  score_type = COALESCE($9, score_type),
  host = COALESCE($10, host),
  port = COALESCE($11, port),
  attachments = COALESCE($12, attachments)
WHERE id = $13
`

type UpdateChallengeParams struct {
	Name        sql.NullString `json:"name"`
	Category    sql.NullString `json:"category"`
	Description sql.NullString `json:"description"`
	Difficulty  sql.NullString `json:"difficulty"`
	Authors     sql.NullString `json:"authors"`
	Type        NullDeployType `json:"type"`
	Hidden      sql.NullBool   `json:"hidden"`
	MaxPoints   sql.NullInt32  `json:"max_points"`
	ScoreType   NullScoreType  `json:"score_type"`
	Host        sql.NullString `json:"host"`
	Port        sql.NullInt32  `json:"port"`
	Attachments sql.NullString `json:"attachments"`
	ChallID     int32          `json:"chall_id"`
}

// Updates the challenge with the given ID
func (q *Queries) UpdateChallenge(ctx context.Context, arg UpdateChallengeParams) error {
	_, err := q.exec(ctx, q.updateChallengeStmt, updateChallenge,
		arg.Name,
		arg.Category,
		arg.Description,
		arg.Difficulty,
		arg.Authors,
		arg.Type,
		arg.Hidden,
		arg.MaxPoints,
		arg.ScoreType,
		arg.Host,
		arg.Port,
		arg.Attachments,
		arg.ChallID,
	)
	return err
}

const updateChallengesCategory = `-- name: UpdateChallengesCategory :exec
UPDATE challenges SET category = $1 WHERE category = $2
`

type UpdateChallengesCategoryParams struct {
	NewCategory string `json:"new_category"`
	OldCategory string `json:"old_category"`
}

// update category name in challenges table
func (q *Queries) UpdateChallengesCategory(ctx context.Context, arg UpdateChallengesCategoryParams) error {
	_, err := q.exec(ctx, q.updateChallengesCategoryStmt, updateChallengesCategory, arg.NewCategory, arg.OldCategory)
	return err
}

const updateDockerConfigs = `-- name: UpdateDockerConfigs :exec
UPDATE docker_configs
SET
  image = COALESCE($1, image),
  compose = COALESCE($2, compose),
  hash_domain = COALESCE($3, hash_domain),
  lifetime = COALESCE($4, lifetime),
  envs = COALESCE($5, envs),
  max_memory = COALESCE($6, max_memory),
  max_cpu = COALESCE($7, max_cpu)
WHERE chall_id = $8
`

type UpdateDockerConfigsParams struct {
	Image      sql.NullString `json:"image"`
	Compose    sql.NullString `json:"compose"`
	HashDomain sql.NullBool   `json:"hash_domain"`
	Lifetime   sql.NullInt32  `json:"lifetime"`
	Envs       sql.NullString `json:"envs"`
	MaxMemory  sql.NullInt32  `json:"max_memory"`
	MaxCpu     sql.NullString `json:"max_cpu"`
	ChallID    int32          `json:"chall_id"`
}

// Updates the Docker configurations for the challenge with the given ID
func (q *Queries) UpdateDockerConfigs(ctx context.Context, arg UpdateDockerConfigsParams) error {
	_, err := q.exec(ctx, q.updateDockerConfigsStmt, updateDockerConfigs,
		arg.Image,
		arg.Compose,
		arg.HashDomain,
		arg.Lifetime,
		arg.Envs,
		arg.MaxMemory,
		arg.MaxCpu,
		arg.ChallID,
	)
	return err
}

const updateFlag = `-- name: UpdateFlag :exec
UPDATE flags
  SET
    flag = COALESCE($3, flag),
    regex = COALESCE($4, regex)
  WHERE chall_id = $1
    AND flag = $2
`

type UpdateFlagParams struct {
	ChallID int32          `json:"chall_id"`
	Flag    string         `json:"flag"`
	NewFlag sql.NullString `json:"new_flag"`
	Regex   sql.NullBool   `json:"regex"`
}

func (q *Queries) UpdateFlag(ctx context.Context, arg UpdateFlagParams) error {
	_, err := q.exec(ctx, q.updateFlagStmt, updateFlag,
		arg.ChallID,
		arg.Flag,
		arg.NewFlag,
		arg.Regex,
	)
	return err
}

const updateInstanceDockerID = `-- name: UpdateInstanceDockerID :exec
UPDATE instances
  SET docker_id = $3
  WHERE team_id = $1 AND chall_id = $2
`

type UpdateInstanceDockerIDParams struct {
	TeamID   int32          `json:"team_id"`
	ChallID  int32          `json:"chall_id"`
	DockerID sql.NullString `json:"docker_id"`
}

// Adds the container ID to the instance
func (q *Queries) UpdateInstanceDockerID(ctx context.Context, arg UpdateInstanceDockerIDParams) error {
	_, err := q.exec(ctx, q.updateInstanceDockerIDStmt, updateInstanceDockerID, arg.TeamID, arg.ChallID, arg.DockerID)
	return err
}

const updateInstanceExpire = `-- name: UpdateInstanceExpire :exec
UPDATE instances
  SET expires_at = $3
  WHERE team_id = $1 AND chall_id = $2
`

type UpdateInstanceExpireParams struct {
	TeamID    int32     `json:"team_id"`
	ChallID   int32     `json:"chall_id"`
	ExpiresAt time.Time `json:"expires_at"`
}

// Update an instance expiration time
func (q *Queries) UpdateInstanceExpire(ctx context.Context, arg UpdateInstanceExpireParams) error {
	_, err := q.exec(ctx, q.updateInstanceExpireStmt, updateInstanceExpire, arg.TeamID, arg.ChallID, arg.ExpiresAt)
	return err
}

const updateTag = `-- name: UpdateTag :exec
UPDATE tags SET name = $2 WHERE chall_id = $1 AND name = $3
`

type UpdateTagParams struct {
	ChallID int32  `json:"chall_id"`
	NewName string `json:"new_name"`
	OldName string `json:"old_name"`
}

// Updates the name of a challenge tag
func (q *Queries) UpdateTag(ctx context.Context, arg UpdateTagParams) error {
	_, err := q.exec(ctx, q.updateTagStmt, updateTag, arg.ChallID, arg.NewName, arg.OldName)
	return err
}

const updateTeam = `-- name: UpdateTeam :exec
UPDATE teams
SET
  name = COALESCE($2, name),
  country = COALESCE($3, country),
  image = COALESCE($4, image),
  bio = COALESCE($5, bio)
WHERE id = $1
`

type UpdateTeamParams struct {
	ID      int32          `json:"id"`
	Name    sql.NullString `json:"name"`
	Country sql.NullString `json:"country"`
	Image   sql.NullString `json:"image"`
	Bio     sql.NullString `json:"bio"`
}

// Update team details
func (q *Queries) UpdateTeam(ctx context.Context, arg UpdateTeamParams) error {
	_, err := q.exec(ctx, q.updateTeamStmt, updateTeam,
		arg.ID,
		arg.Name,
		arg.Country,
		arg.Image,
		arg.Bio,
	)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
SET
  name = COALESCE($2, name),
  country = COALESCE($3, country),
  image = COALESCE($4, image)
WHERE id = $1
`

type UpdateUserParams struct {
	ID      int32          `json:"id"`
	Name    sql.NullString `json:"name"`
	Country sql.NullString `json:"country"`
	Image   sql.NullString `json:"image"`
}

// Update user details
func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.exec(ctx, q.updateUserStmt, updateUser,
		arg.ID,
		arg.Name,
		arg.Country,
		arg.Image,
	)
	return err
}
