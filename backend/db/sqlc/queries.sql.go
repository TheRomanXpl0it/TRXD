// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const addTeamMember = `-- name: AddTeamMember :exec
UPDATE users SET team_id = $1 WHERE id = $2 AND team_id IS NULL
`

type AddTeamMemberParams struct {
	TeamID sql.NullInt32 `json:"team_id"`
	ID     int32         `json:"id"`
}

// Assign a user to a team
func (q *Queries) AddTeamMember(ctx context.Context, arg AddTeamMemberParams) error {
	_, err := q.exec(ctx, q.addTeamMemberStmt, addTeamMember, arg.TeamID, arg.ID)
	return err
}

const checkFlags = `-- name: CheckFlags :one
SELECT BOOL_OR(($1 = flag) OR (regex AND $1 ~ flag)) FROM flags WHERE chall_id = $2
`

type CheckFlagsParams struct {
	Flag    string `json:"flag"`
	ChallID int32  `json:"chall_id"`
}

// Check if a flag matches any flags for a challenge
func (q *Queries) CheckFlags(ctx context.Context, arg CheckFlagsParams) (bool, error) {
	row := q.queryRow(ctx, q.checkFlagsStmt, checkFlags, arg.Flag, arg.ChallID)
	var bool_or bool
	err := row.Scan(&bool_or)
	return bool_or, err
}

const createCategory = `-- name: CreateCategory :exec
INSERT INTO categories (name, icon) VALUES ($1, $2)
`

type CreateCategoryParams struct {
	Name string `json:"name"`
	Icon string `json:"icon"`
}

// Insert a new category
func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) error {
	_, err := q.exec(ctx, q.createCategoryStmt, createCategory, arg.Name, arg.Icon)
	return err
}

const createChallenge = `-- name: CreateChallenge :one
INSERT INTO challenges (name, category, description, type, max_points, score_type)
  VALUES ($1, $2, $3, $4, $5, $6) RETURNING id
`

type CreateChallengeParams struct {
	Name        string     `json:"name"`
	Category    string     `json:"category"`
	Description string     `json:"description"`
	Type        DeployType `json:"type"`
	MaxPoints   int32      `json:"max_points"`
	ScoreType   ScoreType  `json:"score_type"`
}

// Insert a new challenge
func (q *Queries) CreateChallenge(ctx context.Context, arg CreateChallengeParams) (int32, error) {
	row := q.queryRow(ctx, q.createChallengeStmt, createChallenge,
		arg.Name,
		arg.Category,
		arg.Description,
		arg.Type,
		arg.MaxPoints,
		arg.ScoreType,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createFlag = `-- name: CreateFlag :exec
INSERT INTO flags (flag, chall_id, regex) VALUES ($1, $2, $3)
`

type CreateFlagParams struct {
	Flag    string `json:"flag"`
	ChallID int32  `json:"chall_id"`
	Regex   bool   `json:"regex"`
}

// Insert a new flag for a challenge
func (q *Queries) CreateFlag(ctx context.Context, arg CreateFlagParams) error {
	_, err := q.exec(ctx, q.createFlagStmt, createFlag, arg.Flag, arg.ChallID, arg.Regex)
	return err
}

const createInstance = `-- name: CreateInstance :one
WITH info AS (
    SELECT generate_instance_remote(
      $1,
      $2,
      $4::BOOLEAN
    ) AS remote
  )
INSERT INTO instances (team_id, chall_id, expires_at, host, port)
  VALUES ($1, $2, $3,
    (SELECT (remote).host FROM info), (SELECT (remote).port FROM info))
RETURNING host, port
`

type CreateInstanceParams struct {
	TeamID     int32     `json:"team_id"`
	ChallID    int32     `json:"chall_id"`
	ExpiresAt  time.Time `json:"expires_at"`
	HashDomain bool      `json:"hash_domain"`
}

type CreateInstanceRow struct {
	Host string        `json:"host"`
	Port sql.NullInt32 `json:"port"`
}

// Creates a new instance for a team
func (q *Queries) CreateInstance(ctx context.Context, arg CreateInstanceParams) (CreateInstanceRow, error) {
	row := q.queryRow(ctx, q.createInstanceStmt, createInstance,
		arg.TeamID,
		arg.ChallID,
		arg.ExpiresAt,
		arg.HashDomain,
	)
	var i CreateInstanceRow
	err := row.Scan(&i.Host, &i.Port)
	return i, err
}

const createTag = `-- name: CreateTag :exec
INSERT INTO tags (chall_id, name) VALUES ($1, $2)
`

type CreateTagParams struct {
	ChallID int32  `json:"chall_id"`
	Name    string `json:"name"`
}

// Creates a named tag for a challenge
func (q *Queries) CreateTag(ctx context.Context, arg CreateTagParams) error {
	_, err := q.exec(ctx, q.createTagStmt, createTag, arg.ChallID, arg.Name)
	return err
}

const deleteCategory = `-- name: DeleteCategory :exec
DELETE FROM categories WHERE name = $1
`

// Delete a category and all associated challenges
func (q *Queries) DeleteCategory(ctx context.Context, name string) error {
	_, err := q.exec(ctx, q.deleteCategoryStmt, deleteCategory, name)
	return err
}

const deleteChallenge = `-- name: DeleteChallenge :exec
DELETE FROM challenges WHERE id = $1
`

// Delete a challenge and all associated flags
func (q *Queries) DeleteChallenge(ctx context.Context, id int32) error {
	_, err := q.exec(ctx, q.deleteChallengeStmt, deleteChallenge, id)
	return err
}

const deleteFlag = `-- name: DeleteFlag :exec
DELETE FROM flags WHERE chall_id = $1 AND flag = $2
`

type DeleteFlagParams struct {
	ChallID int32  `json:"chall_id"`
	Flag    string `json:"flag"`
}

// Delete a flag from a challenge
func (q *Queries) DeleteFlag(ctx context.Context, arg DeleteFlagParams) error {
	_, err := q.exec(ctx, q.deleteFlagStmt, deleteFlag, arg.ChallID, arg.Flag)
	return err
}

const deleteInstance = `-- name: DeleteInstance :exec
DELETE FROM instances
  WHERE team_id = $1 AND chall_id = $2
`

type DeleteInstanceParams struct {
	TeamID  int32 `json:"team_id"`
	ChallID int32 `json:"chall_id"`
}

// Delete an instance
func (q *Queries) DeleteInstance(ctx context.Context, arg DeleteInstanceParams) error {
	_, err := q.exec(ctx, q.deleteInstanceStmt, deleteInstance, arg.TeamID, arg.ChallID)
	return err
}

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM tags WHERE chall_id = $1 AND name = $2
`

type DeleteTagParams struct {
	ChallID int32  `json:"chall_id"`
	Name    string `json:"name"`
}

// Deletes a challenge tag by name
func (q *Queries) DeleteTag(ctx context.Context, arg DeleteTagParams) error {
	_, err := q.exec(ctx, q.deleteTagStmt, deleteTag, arg.ChallID, arg.Name)
	return err
}

const getCategory = `-- name: GetCategory :one
SELECT name, visible_challs, icon FROM categories WHERE name = $1
`

// fetch category by name
func (q *Queries) GetCategory(ctx context.Context, name string) (Category, error) {
	row := q.queryRow(ctx, q.getCategoryStmt, getCategory, name)
	var i Category
	err := row.Scan(&i.Name, &i.VisibleChalls, &i.Icon)
	return i, err
}

const getChallDockerConfig = `-- name: GetChallDockerConfig :one
SELECT chall_id, image, compose, hash_domain, lifetime, envs, max_memory, max_cpu FROM docker_configs WHERE chall_id = $1
`

func (q *Queries) GetChallDockerConfig(ctx context.Context, challID int32) (DockerConfig, error) {
	row := q.queryRow(ctx, q.getChallDockerConfigStmt, getChallDockerConfig, challID)
	var i DockerConfig
	err := row.Scan(
		&i.ChallID,
		&i.Image,
		&i.Compose,
		&i.HashDomain,
		&i.Lifetime,
		&i.Envs,
		&i.MaxMemory,
		&i.MaxCpu,
	)
	return i, err
}

const getChallengeSolves = `-- name: GetChallengeSolves :many
SELECT teams.id, teams.name, submissions.timestamp
  FROM submissions
  JOIN users ON users.id = submissions.user_id
  JOIN teams ON users.team_id = teams.id
  WHERE users.role = 'Player'
    AND submissions.chall_id = $1
    AND submissions.status = 'Correct'
  ORDER BY submissions.timestamp ASC
`

type GetChallengeSolvesRow struct {
	ID        int32     `json:"id"`
	Name      string    `json:"name"`
	Timestamp time.Time `json:"timestamp"`
}

// Retrieve all teams that solved a challenge
func (q *Queries) GetChallengeSolves(ctx context.Context, challID int32) ([]GetChallengeSolvesRow, error) {
	rows, err := q.query(ctx, q.getChallengeSolvesStmt, getChallengeSolves, challID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChallengeSolvesRow
	for rows.Next() {
		var i GetChallengeSolvesRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Timestamp); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChallenges = `-- name: GetChallenges :many
SELECT id, name, category, description, difficulty, authors, type, hidden, max_points, score_type, points, solves, host, port, attachments FROM challenges
`

// Retrieve all challenges
func (q *Queries) GetChallenges(ctx context.Context) ([]Challenge, error) {
	rows, err := q.query(ctx, q.getChallengesStmt, getChallenges)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Challenge
	for rows.Next() {
		var i Challenge
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Category,
			&i.Description,
			&i.Difficulty,
			&i.Authors,
			&i.Type,
			&i.Hidden,
			&i.MaxPoints,
			&i.ScoreType,
			&i.Points,
			&i.Solves,
			&i.Host,
			&i.Port,
			&i.Attachments,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConfigs = `-- name: GetConfigs :many
SELECT key, type, value, description FROM configs ORDER BY key
`

// Fetches all configuration settings
func (q *Queries) GetConfigs(ctx context.Context) ([]Config, error) {
	rows, err := q.query(ctx, q.getConfigsStmt, getConfigs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Config
	for rows.Next() {
		var i Config
		if err := rows.Scan(
			&i.Key,
			&i.Type,
			&i.Value,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlagsByChallenge = `-- name: GetFlagsByChallenge :many
SELECT flag, regex FROM flags WHERE chall_id = $1
`

type GetFlagsByChallengeRow struct {
	Flag  string `json:"flag"`
	Regex bool   `json:"regex"`
}

// Retrieve all flags associated with a challenge
func (q *Queries) GetFlagsByChallenge(ctx context.Context, challID int32) ([]GetFlagsByChallengeRow, error) {
	rows, err := q.query(ctx, q.getFlagsByChallengeStmt, getFlagsByChallenge, challID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFlagsByChallengeRow
	for rows.Next() {
		var i GetFlagsByChallengeRow
		if err := rows.Scan(&i.Flag, &i.Regex); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInstance = `-- name: GetInstance :one
SELECT team_id, chall_id, expires_at, host, port, docker_id FROM instances WHERE chall_id = $1 AND team_id = $2
`

type GetInstanceParams struct {
	ChallID int32 `json:"chall_id"`
	TeamID  int32 `json:"team_id"`
}

// Gets an instance by ID
func (q *Queries) GetInstance(ctx context.Context, arg GetInstanceParams) (Instance, error) {
	row := q.queryRow(ctx, q.getInstanceStmt, getInstance, arg.ChallID, arg.TeamID)
	var i Instance
	err := row.Scan(
		&i.TeamID,
		&i.ChallID,
		&i.ExpiresAt,
		&i.Host,
		&i.Port,
		&i.DockerID,
	)
	return i, err
}

const getInstanceInfo = `-- name: GetInstanceInfo :one
SELECT expires_at, host, port FROM instances WHERE team_id = $1 AND chall_id = $2
`

type GetInstanceInfoParams struct {
	TeamID  int32 `json:"team_id"`
	ChallID int32 `json:"chall_id"`
}

type GetInstanceInfoRow struct {
	ExpiresAt time.Time     `json:"expires_at"`
	Host      string        `json:"host"`
	Port      sql.NullInt32 `json:"port"`
}

// Retrieve the instance associated with a challenge and team
func (q *Queries) GetInstanceInfo(ctx context.Context, arg GetInstanceInfoParams) (GetInstanceInfoRow, error) {
	row := q.queryRow(ctx, q.getInstanceInfoStmt, getInstanceInfo, arg.TeamID, arg.ChallID)
	var i GetInstanceInfoRow
	err := row.Scan(&i.ExpiresAt, &i.Host, &i.Port)
	return i, err
}

const getNextInstanceToDelete = `-- name: GetNextInstanceToDelete :one
SELECT team_id, chall_id, expires_at, docker_id
  FROM instances
  WHERE expires_at < NOW() + (
    (SELECT value
      FROM configs
      WHERE key='reclaim-instance-interval'
    ) || ' seconds')::INTERVAL
  ORDER BY expires_at ASC
  LIMIT 1
`

type GetNextInstanceToDeleteRow struct {
	TeamID    int32          `json:"team_id"`
	ChallID   int32          `json:"chall_id"`
	ExpiresAt time.Time      `json:"expires_at"`
	DockerID  sql.NullString `json:"docker_id"`
}

// Retrieves the next instance to delete
func (q *Queries) GetNextInstanceToDelete(ctx context.Context) (GetNextInstanceToDeleteRow, error) {
	row := q.queryRow(ctx, q.getNextInstanceToDeleteStmt, getNextInstanceToDelete)
	var i GetNextInstanceToDeleteRow
	err := row.Scan(
		&i.TeamID,
		&i.ChallID,
		&i.ExpiresAt,
		&i.DockerID,
	)
	return i, err
}

const getTeamMembers = `-- name: GetTeamMembers :many
SELECT id, name, role, score FROM users WHERE team_id = $1 ORDER BY id
`

type GetTeamMembersRow struct {
	ID    int32    `json:"id"`
	Name  string   `json:"name"`
	Role  UserRole `json:"role"`
	Score int32    `json:"score"`
}

// Retrieve all members of a team by team ID
func (q *Queries) GetTeamMembers(ctx context.Context, teamID sql.NullInt32) ([]GetTeamMembersRow, error) {
	rows, err := q.query(ctx, q.getTeamMembersStmt, getTeamMembers, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamMembersRow
	for rows.Next() {
		var i GetTeamMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Role,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamSolves = `-- name: GetTeamSolves :many
SELECT c.id, c.name, c.category, s.first_blood, s.timestamp, s.user_id
  FROM submissions s
  JOIN users u ON u.id = s.user_id
  JOIN teams t ON u.team_id = t.id
  JOIN challenges c ON c.id = s.chall_id
  WHERE u.role = 'Player'
    AND t.id = $1
    AND s.status = 'Correct'
  ORDER BY s.timestamp DESC
`

type GetTeamSolvesRow struct {
	ID         int32     `json:"id"`
	Name       string    `json:"name"`
	Category   string    `json:"category"`
	FirstBlood bool      `json:"first_blood"`
	Timestamp  time.Time `json:"timestamp"`
	UserID     int32     `json:"user_id"`
}

// Retrieve all challenges solved by a team's members
func (q *Queries) GetTeamSolves(ctx context.Context, id int32) ([]GetTeamSolvesRow, error) {
	rows, err := q.query(ctx, q.getTeamSolvesStmt, getTeamSolves, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamSolvesRow
	for rows.Next() {
		var i GetTeamSolvesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Category,
			&i.FirstBlood,
			&i.Timestamp,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamsPreview = `-- name: GetTeamsPreview :many
SELECT id, name, score, country, image
  FROM teams
  ORDER BY id
`

type GetTeamsPreviewRow struct {
	ID      int32          `json:"id"`
	Name    string         `json:"name"`
	Score   int32          `json:"score"`
	Country sql.NullString `json:"country"`
	Image   sql.NullString `json:"image"`
}

// Retrieve all teams
func (q *Queries) GetTeamsPreview(ctx context.Context) ([]GetTeamsPreviewRow, error) {
	rows, err := q.query(ctx, q.getTeamsPreviewStmt, getTeamsPreview)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamsPreviewRow
	for rows.Next() {
		var i GetTeamsPreviewRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Score,
			&i.Country,
			&i.Image,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamsScoreboard = `-- name: GetTeamsScoreboard :many
SELECT id, name, score, country, image
  FROM teams
  ORDER BY score DESC
`

type GetTeamsScoreboardRow struct {
	ID      int32          `json:"id"`
	Name    string         `json:"name"`
	Score   int32          `json:"score"`
	Country sql.NullString `json:"country"`
	Image   sql.NullString `json:"image"`
}

// Retrieve all teams
func (q *Queries) GetTeamsScoreboard(ctx context.Context) ([]GetTeamsScoreboardRow, error) {
	rows, err := q.query(ctx, q.getTeamsScoreboardStmt, getTeamsScoreboard)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamsScoreboardRow
	for rows.Next() {
		var i GetTeamsScoreboardRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Score,
			&i.Country,
			&i.Image,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, name, email, password_hash, password_salt, created_at, score, role, team_id, country, image FROM users WHERE email = $1
`

// Retrieve a user by their email address
func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.queryRow(ctx, q.getUserByEmailStmt, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.PasswordSalt,
		&i.CreatedAt,
		&i.Score,
		&i.Role,
		&i.TeamID,
		&i.Country,
		&i.Image,
	)
	return i, err
}

const getUserSolves = `-- name: GetUserSolves :many
SELECT c.id, c.name, c.category, s.first_blood, s.timestamp
  FROM submissions s
  JOIN challenges c ON s.chall_id = c.id
  WHERE s.user_id = $1
    AND s.status = 'Correct'
`

type GetUserSolvesRow struct {
	ID         int32     `json:"id"`
	Name       string    `json:"name"`
	Category   string    `json:"category"`
	FirstBlood bool      `json:"first_blood"`
	Timestamp  time.Time `json:"timestamp"`
}

// Retrieve all challenges solved by a user
func (q *Queries) GetUserSolves(ctx context.Context, userID int32) ([]GetUserSolvesRow, error) {
	rows, err := q.query(ctx, q.getUserSolvesStmt, getUserSolves, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserSolvesRow
	for rows.Next() {
		var i GetUserSolvesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Category,
			&i.FirstBlood,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersPreview = `-- name: GetUsersPreview :many
SELECT id, name, email, role, score, country, image
  FROM users
  ORDER BY id ASC
`

type GetUsersPreviewRow struct {
	ID      int32          `json:"id"`
	Name    string         `json:"name"`
	Email   string         `json:"email"`
	Role    UserRole       `json:"role"`
	Score   int32          `json:"score"`
	Country sql.NullString `json:"country"`
	Image   sql.NullString `json:"image"`
}

// Retrieve all users
func (q *Queries) GetUsersPreview(ctx context.Context) ([]GetUsersPreviewRow, error) {
	rows, err := q.query(ctx, q.getUsersPreviewStmt, getUsersPreview)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersPreviewRow
	for rows.Next() {
		var i GetUsersPreviewRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Role,
			&i.Score,
			&i.Country,
			&i.Image,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isChallengeFirstBlood = `-- name: IsChallengeFirstBlood :one
SELECT first_blood
  FROM submissions
  JOIN users ON users.id = submissions.user_id
  JOIN teams ON users.team_id = teams.id
    AND teams.id = (SELECT team_id FROM users WHERE users.id = $2)
  WHERE users.role = 'Player'
    AND submissions.status = 'Correct'
    AND submissions.chall_id = $1
`

type IsChallengeFirstBloodParams struct {
	ChallID int32 `json:"chall_id"`
	ID      int32 `json:"id"`
}

// Check if a challenge is solved (and is a first blood) by a user's team
func (q *Queries) IsChallengeFirstBlood(ctx context.Context, arg IsChallengeFirstBloodParams) (bool, error) {
	row := q.queryRow(ctx, q.isChallengeFirstBloodStmt, isChallengeFirstBlood, arg.ChallID, arg.ID)
	var first_blood bool
	err := row.Scan(&first_blood)
	return first_blood, err
}

const registerTeam = `-- name: RegisterTeam :exec
WITH locked_user AS (
    SELECT id FROM users
    WHERE id = $1 AND team_id IS NULL
    FOR UPDATE
  ),
  new_team AS (
    INSERT INTO teams (name, password_hash, password_salt)
    SELECT $2, $3, $4
    FROM locked_user
    RETURNING id, name, password_hash, password_salt, score, country, image, bio
  )
UPDATE users
  SET team_id = new_team.id
  FROM new_team
  WHERE users.id = $1
`

type RegisterTeamParams struct {
	ID           int32  `json:"id"`
	Name         string `json:"name"`
	PasswordHash string `json:"password_hash"`
	PasswordSalt string `json:"password_salt"`
}

// Insert a new team and add the founder user to the team
func (q *Queries) RegisterTeam(ctx context.Context, arg RegisterTeamParams) error {
	_, err := q.exec(ctx, q.registerTeamStmt, registerTeam,
		arg.ID,
		arg.Name,
		arg.PasswordHash,
		arg.PasswordSalt,
	)
	return err
}

const registerUser = `-- name: RegisterUser :one
INSERT INTO users (name, email, password_hash, password_salt, role) VALUES ($1, $2, $3, $4, $5) RETURNING id, name, email, password_hash, password_salt, created_at, score, role, team_id, country, image
`

type RegisterUserParams struct {
	Name         string   `json:"name"`
	Email        string   `json:"email"`
	PasswordHash string   `json:"password_hash"`
	PasswordSalt string   `json:"password_salt"`
	Role         UserRole `json:"role"`
}

// Insert a new user and return the created user
func (q *Queries) RegisterUser(ctx context.Context, arg RegisterUserParams) (User, error) {
	row := q.queryRow(ctx, q.registerUserStmt, registerUser,
		arg.Name,
		arg.Email,
		arg.PasswordHash,
		arg.PasswordSalt,
		arg.Role,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.PasswordSalt,
		&i.CreatedAt,
		&i.Score,
		&i.Role,
		&i.TeamID,
		&i.Country,
		&i.Image,
	)
	return i, err
}

const resetTeamPassword = `-- name: ResetTeamPassword :exec
UPDATE teams SET password_hash = $2, password_salt = $3 WHERE id = $1
`

type ResetTeamPasswordParams struct {
	ID           int32  `json:"id"`
	PasswordHash string `json:"password_hash"`
	PasswordSalt string `json:"password_salt"`
}

// Reset a team's password to a new password
func (q *Queries) ResetTeamPassword(ctx context.Context, arg ResetTeamPasswordParams) error {
	_, err := q.exec(ctx, q.resetTeamPasswordStmt, resetTeamPassword, arg.ID, arg.PasswordHash, arg.PasswordSalt)
	return err
}

const resetUserPassword = `-- name: ResetUserPassword :exec
UPDATE users SET password_hash = $2, password_salt = $3 WHERE id = $1
`

type ResetUserPasswordParams struct {
	ID           int32  `json:"id"`
	PasswordHash string `json:"password_hash"`
	PasswordSalt string `json:"password_salt"`
}

// Reset a user's password to a new password
func (q *Queries) ResetUserPassword(ctx context.Context, arg ResetUserPasswordParams) error {
	_, err := q.exec(ctx, q.resetUserPasswordStmt, resetUserPassword, arg.ID, arg.PasswordHash, arg.PasswordSalt)
	return err
}

const submit = `-- name: Submit :one
WITH challenge AS (
    SELECT challenges.id FROM challenges
    WHERE challenges.id = $2 FOR UPDATE
  )
INSERT INTO submissions (user_id, chall_id, status, flag)
  VALUES ($1, (SELECT id FROM challenge), $4, $3)
  RETURNING status, first_blood
`

type SubmitParams struct {
	UserID int32            `json:"user_id"`
	ID     int32            `json:"id"`
	Flag   string           `json:"flag"`
	Status SubmissionStatus `json:"status"`
}

type SubmitRow struct {
	Status     SubmissionStatus `json:"status"`
	FirstBlood bool             `json:"first_blood"`
}

// Insert a new submission
func (q *Queries) Submit(ctx context.Context, arg SubmitParams) (SubmitRow, error) {
	row := q.queryRow(ctx, q.submitStmt, submit,
		arg.UserID,
		arg.ID,
		arg.Flag,
		arg.Status,
	)
	var i SubmitRow
	err := row.Scan(&i.Status, &i.FirstBlood)
	return i, err
}

const updateCategoryIcon = `-- name: UpdateCategoryIcon :exec
UPDATE categories SET icon = $2 WHERE name = $1
`

type UpdateCategoryIconParams struct {
	Name string `json:"name"`
	Icon string `json:"icon"`
}

// update category icon by name
func (q *Queries) UpdateCategoryIcon(ctx context.Context, arg UpdateCategoryIconParams) error {
	_, err := q.exec(ctx, q.updateCategoryIconStmt, updateCategoryIcon, arg.Name, arg.Icon)
	return err
}

const updateChallenge = `-- name: UpdateChallenge :exec
UPDATE challenges
SET
  name = COALESCE($1, name),
  category = COALESCE($2, category),
  description = COALESCE($3, description),
  difficulty = COALESCE($4, difficulty),
  authors = COALESCE($5, authors),
  type = COALESCE($6, type),
  hidden = COALESCE($7, hidden),
  max_points = COALESCE($8, max_points),
  score_type = COALESCE($9, score_type),
  host = COALESCE($10, host),
  port = COALESCE($11, port),
  attachments = COALESCE($12, attachments)
WHERE id = $13
`

type UpdateChallengeParams struct {
	Name        sql.NullString `json:"name"`
	Category    sql.NullString `json:"category"`
	Description sql.NullString `json:"description"`
	Difficulty  sql.NullString `json:"difficulty"`
	Authors     sql.NullString `json:"authors"`
	Type        NullDeployType `json:"type"`
	Hidden      sql.NullBool   `json:"hidden"`
	MaxPoints   sql.NullInt32  `json:"max_points"`
	ScoreType   NullScoreType  `json:"score_type"`
	Host        sql.NullString `json:"host"`
	Port        sql.NullInt32  `json:"port"`
	Attachments sql.NullString `json:"attachments"`
	ChallID     int32          `json:"chall_id"`
}

// Updates the challenge with the given ID
func (q *Queries) UpdateChallenge(ctx context.Context, arg UpdateChallengeParams) error {
	_, err := q.exec(ctx, q.updateChallengeStmt, updateChallenge,
		arg.Name,
		arg.Category,
		arg.Description,
		arg.Difficulty,
		arg.Authors,
		arg.Type,
		arg.Hidden,
		arg.MaxPoints,
		arg.ScoreType,
		arg.Host,
		arg.Port,
		arg.Attachments,
		arg.ChallID,
	)
	return err
}

const updateChallengesCategory = `-- name: UpdateChallengesCategory :exec
UPDATE challenges SET category = $1 WHERE category = $2
`

type UpdateChallengesCategoryParams struct {
	NewCategory string `json:"new_category"`
	OldCategory string `json:"old_category"`
}

// update category name in challenges table
func (q *Queries) UpdateChallengesCategory(ctx context.Context, arg UpdateChallengesCategoryParams) error {
	_, err := q.exec(ctx, q.updateChallengesCategoryStmt, updateChallengesCategory, arg.NewCategory, arg.OldCategory)
	return err
}

const updateDockerConfigs = `-- name: UpdateDockerConfigs :exec
UPDATE docker_configs
SET
  image = COALESCE($1, image),
  compose = COALESCE($2, compose),
  hash_domain = COALESCE($3, hash_domain),
  lifetime = COALESCE($4, lifetime),
  envs = COALESCE($5, envs),
  max_memory = COALESCE($6, max_memory),
  max_cpu = COALESCE($7, max_cpu)
WHERE chall_id = $8
`

type UpdateDockerConfigsParams struct {
	Image      sql.NullString `json:"image"`
	Compose    sql.NullString `json:"compose"`
	HashDomain sql.NullBool   `json:"hash_domain"`
	Lifetime   sql.NullInt32  `json:"lifetime"`
	Envs       sql.NullString `json:"envs"`
	MaxMemory  sql.NullInt32  `json:"max_memory"`
	MaxCpu     sql.NullString `json:"max_cpu"`
	ChallID    int32          `json:"chall_id"`
}

// Updates the Docker configurations for the challenge with the given ID
func (q *Queries) UpdateDockerConfigs(ctx context.Context, arg UpdateDockerConfigsParams) error {
	_, err := q.exec(ctx, q.updateDockerConfigsStmt, updateDockerConfigs,
		arg.Image,
		arg.Compose,
		arg.HashDomain,
		arg.Lifetime,
		arg.Envs,
		arg.MaxMemory,
		arg.MaxCpu,
		arg.ChallID,
	)
	return err
}

const updateFlag = `-- name: UpdateFlag :exec
UPDATE flags
  SET
    flag = COALESCE($3, flag),
    regex = COALESCE($4, regex)
  WHERE chall_id = $1
    AND flag = $2
`

type UpdateFlagParams struct {
	ChallID int32          `json:"chall_id"`
	Flag    string         `json:"flag"`
	NewFlag sql.NullString `json:"new_flag"`
	Regex   sql.NullBool   `json:"regex"`
}

func (q *Queries) UpdateFlag(ctx context.Context, arg UpdateFlagParams) error {
	_, err := q.exec(ctx, q.updateFlagStmt, updateFlag,
		arg.ChallID,
		arg.Flag,
		arg.NewFlag,
		arg.Regex,
	)
	return err
}

const updateInstance = `-- name: UpdateInstance :exec
UPDATE instances
  SET expires_at = $3
  WHERE team_id = $1 AND chall_id = $2
`

type UpdateInstanceParams struct {
	TeamID    int32     `json:"team_id"`
	ChallID   int32     `json:"chall_id"`
	ExpiresAt time.Time `json:"expires_at"`
}

// Update an instance expiration time
func (q *Queries) UpdateInstance(ctx context.Context, arg UpdateInstanceParams) error {
	_, err := q.exec(ctx, q.updateInstanceStmt, updateInstance, arg.TeamID, arg.ChallID, arg.ExpiresAt)
	return err
}

const updateInstanceDockerID = `-- name: UpdateInstanceDockerID :exec
UPDATE instances
  SET docker_id = $3
  WHERE team_id = $1 AND chall_id = $2
`

type UpdateInstanceDockerIDParams struct {
	TeamID   int32          `json:"team_id"`
	ChallID  int32          `json:"chall_id"`
	DockerID sql.NullString `json:"docker_id"`
}

// Adds the container ID to the instance
func (q *Queries) UpdateInstanceDockerID(ctx context.Context, arg UpdateInstanceDockerIDParams) error {
	_, err := q.exec(ctx, q.updateInstanceDockerIDStmt, updateInstanceDockerID, arg.TeamID, arg.ChallID, arg.DockerID)
	return err
}

const updateTag = `-- name: UpdateTag :exec
UPDATE tags SET name = $2 WHERE chall_id = $1 AND name = $3
`

type UpdateTagParams struct {
	ChallID int32  `json:"chall_id"`
	NewName string `json:"new_name"`
	OldName string `json:"old_name"`
}

// Updates the name of a challenge tag
func (q *Queries) UpdateTag(ctx context.Context, arg UpdateTagParams) error {
	_, err := q.exec(ctx, q.updateTagStmt, updateTag, arg.ChallID, arg.NewName, arg.OldName)
	return err
}

const updateTeam = `-- name: UpdateTeam :exec
UPDATE teams
SET
  name = COALESCE($2, name),
  country = COALESCE($3, country),
  image = COALESCE($4, image),
  bio = COALESCE($5, bio)
WHERE id = $1
`

type UpdateTeamParams struct {
	ID      int32          `json:"id"`
	Name    sql.NullString `json:"name"`
	Country sql.NullString `json:"country"`
	Image   sql.NullString `json:"image"`
	Bio     sql.NullString `json:"bio"`
}

// Update team details
func (q *Queries) UpdateTeam(ctx context.Context, arg UpdateTeamParams) error {
	_, err := q.exec(ctx, q.updateTeamStmt, updateTeam,
		arg.ID,
		arg.Name,
		arg.Country,
		arg.Image,
		arg.Bio,
	)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
SET
  name = COALESCE($2, name),
  country = COALESCE($3, country),
  image = COALESCE($4, image)
WHERE id = $1
`

type UpdateUserParams struct {
	ID      int32          `json:"id"`
	Name    sql.NullString `json:"name"`
	Country sql.NullString `json:"country"`
	Image   sql.NullString `json:"image"`
}

// Update user details
func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.exec(ctx, q.updateUserStmt, updateUser,
		arg.ID,
		arg.Name,
		arg.Country,
		arg.Image,
	)
	return err
}
