// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const addTeamMember = `-- name: AddTeamMember :exec
UPDATE users SET team_id = $1 WHERE id = $2 AND team_id IS NULL
`

type AddTeamMemberParams struct {
	TeamID sql.NullInt32 `json:"team_id"`
	ID     int32         `json:"id"`
}

// Assign a user to a team
func (q *Queries) AddTeamMember(ctx context.Context, arg AddTeamMemberParams) error {
	_, err := q.exec(ctx, q.addTeamMemberStmt, addTeamMember, arg.TeamID, arg.ID)
	return err
}

const checkFlags = `-- name: CheckFlags :one
SELECT BOOL_OR(($1 = flag) OR (regex AND $1 ~ flag)) FROM flags WHERE chall_id = $2
`

type CheckFlagsParams struct {
	Flag    string `json:"flag"`
	ChallID int32  `json:"chall_id"`
}

// Check if a flag matches any flags for a challenge
func (q *Queries) CheckFlags(ctx context.Context, arg CheckFlagsParams) (bool, error) {
	row := q.queryRow(ctx, q.checkFlagsStmt, checkFlags, arg.Flag, arg.ChallID)
	var bool_or bool
	err := row.Scan(&bool_or)
	return bool_or, err
}

const createCategory = `-- name: CreateCategory :exec
INSERT INTO categories (name, icon) VALUES ($1, $2)
`

type CreateCategoryParams struct {
	Name string `json:"name"`
	Icon string `json:"icon"`
}

// Insert a new category
func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) error {
	_, err := q.exec(ctx, q.createCategoryStmt, createCategory, arg.Name, arg.Icon)
	return err
}

const createChallenge = `-- name: CreateChallenge :one
INSERT INTO challenges (name, category, description, type, max_points, score_type)
  VALUES ($1, $2, $3, $4, $5, $6) RETURNING id
`

type CreateChallengeParams struct {
	Name        string     `json:"name"`
	Category    string     `json:"category"`
	Description string     `json:"description"`
	Type        DeployType `json:"type"`
	MaxPoints   int32      `json:"max_points"`
	ScoreType   ScoreType  `json:"score_type"`
}

// Insert a new challenge
func (q *Queries) CreateChallenge(ctx context.Context, arg CreateChallengeParams) (int32, error) {
	row := q.queryRow(ctx, q.createChallengeStmt, createChallenge,
		arg.Name,
		arg.Category,
		arg.Description,
		arg.Type,
		arg.MaxPoints,
		arg.ScoreType,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createFlag = `-- name: CreateFlag :exec
INSERT INTO flags (flag, chall_id, regex) VALUES ($1, $2, $3)
`

type CreateFlagParams struct {
	Flag    string `json:"flag"`
	ChallID int32  `json:"chall_id"`
	Regex   bool   `json:"regex"`
}

// Insert a new flag for a challenge
func (q *Queries) CreateFlag(ctx context.Context, arg CreateFlagParams) error {
	_, err := q.exec(ctx, q.createFlagStmt, createFlag, arg.Flag, arg.ChallID, arg.Regex)
	return err
}

const deleteCategory = `-- name: DeleteCategory :exec
DELETE FROM categories WHERE name = $1
`

// Delete a category and all associated challenges
func (q *Queries) DeleteCategory(ctx context.Context, name string) error {
	_, err := q.exec(ctx, q.deleteCategoryStmt, deleteCategory, name)
	return err
}

const deleteChallenge = `-- name: DeleteChallenge :exec
DELETE FROM challenges WHERE id = $1
`

// Delete a challenge and all associated flags
func (q *Queries) DeleteChallenge(ctx context.Context, id int32) error {
	_, err := q.exec(ctx, q.deleteChallengeStmt, deleteChallenge, id)
	return err
}

const deleteFlag = `-- name: DeleteFlag :exec
DELETE FROM flags WHERE chall_id = $1 AND flag = $2
`

type DeleteFlagParams struct {
	ChallID int32  `json:"chall_id"`
	Flag    string `json:"flag"`
}

// Delete a flag from a challenge
func (q *Queries) DeleteFlag(ctx context.Context, arg DeleteFlagParams) error {
	_, err := q.exec(ctx, q.deleteFlagStmt, deleteFlag, arg.ChallID, arg.Flag)
	return err
}

const getChallengeSolves = `-- name: GetChallengeSolves :many
SELECT teams.id, teams.name, submissions.timestamp
  FROM submissions
  JOIN users ON users.id = submissions.user_id
  JOIN teams ON users.team_id = teams.id
  WHERE users.role = 'Player'
    AND submissions.chall_id = $1
    AND submissions.status = 'Correct'
  ORDER BY submissions.timestamp ASC
`

type GetChallengeSolvesRow struct {
	ID        int32     `json:"id"`
	Name      string    `json:"name"`
	Timestamp time.Time `json:"timestamp"`
}

// Retrieve all teams that solved a challenge
func (q *Queries) GetChallengeSolves(ctx context.Context, challID int32) ([]GetChallengeSolvesRow, error) {
	rows, err := q.query(ctx, q.getChallengeSolvesStmt, getChallengeSolves, challID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChallengeSolvesRow
	for rows.Next() {
		var i GetChallengeSolvesRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Timestamp); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChallengesPreview = `-- name: GetChallengesPreview :many
SELECT id, name, category, difficulty, type, hidden, points, solves, EXISTS(
  SELECT 1
    FROM submissions
    JOIN users ON users.id = submissions.user_id
    JOIN teams ON users.team_id = teams.id
      AND teams.id = (SELECT team_id FROM users WHERE users.id = $1)
    WHERE users.role = 'Player'
      AND submissions.status = 'Correct'
      AND submissions.chall_id = challenges.id) AS solved
  FROM challenges
`

type GetChallengesPreviewRow struct {
	ID         int32          `json:"id"`
	Name       string         `json:"name"`
	Category   string         `json:"category"`
	Difficulty sql.NullString `json:"difficulty"`
	Type       DeployType     `json:"type"`
	Hidden     bool           `json:"hidden"`
	Points     int32          `json:"points"`
	Solves     int32          `json:"solves"`
	Solved     bool           `json:"solved"`
}

// Retrieve all challenges
func (q *Queries) GetChallengesPreview(ctx context.Context, id int32) ([]GetChallengesPreviewRow, error) {
	rows, err := q.query(ctx, q.getChallengesPreviewStmt, getChallengesPreview, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChallengesPreviewRow
	for rows.Next() {
		var i GetChallengesPreviewRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Category,
			&i.Difficulty,
			&i.Type,
			&i.Hidden,
			&i.Points,
			&i.Solves,
			&i.Solved,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFirstBlood = `-- name: GetFirstBlood :one
SELECT teams.id, teams.name
  FROM submissions
  JOIN users ON users.id = submissions.user_id
  JOIN teams ON users.team_id = teams.id
  WHERE users.role = 'Player'
    AND submissions.chall_id = $1
    AND submissions.status = 'Correct'
  ORDER BY submissions.timestamp ASC
  LIMIT 1
`

type GetFirstBloodRow struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
}

// Retrieve the team that achieved the first blood on a challenge
func (q *Queries) GetFirstBlood(ctx context.Context, challID int32) (GetFirstBloodRow, error) {
	row := q.queryRow(ctx, q.getFirstBloodStmt, getFirstBlood, challID)
	var i GetFirstBloodRow
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getFlagsByChallenge = `-- name: GetFlagsByChallenge :many
SELECT flag, regex FROM flags WHERE chall_id = $1
`

type GetFlagsByChallengeRow struct {
	Flag  string `json:"flag"`
	Regex bool   `json:"regex"`
}

// Retrieve all flags associated with a challenge
func (q *Queries) GetFlagsByChallenge(ctx context.Context, challID int32) ([]GetFlagsByChallengeRow, error) {
	rows, err := q.query(ctx, q.getFlagsByChallengeStmt, getFlagsByChallenge, challID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFlagsByChallengeRow
	for rows.Next() {
		var i GetFlagsByChallengeRow
		if err := rows.Scan(&i.Flag, &i.Regex); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamMembers = `-- name: GetTeamMembers :many
SELECT id, name, role, score FROM users WHERE team_id = $1 ORDER BY id
`

type GetTeamMembersRow struct {
	ID    int32    `json:"id"`
	Name  string   `json:"name"`
	Role  UserRole `json:"role"`
	Score int32    `json:"score"`
}

// Retrieve all members of a team by team ID
func (q *Queries) GetTeamMembers(ctx context.Context, teamID sql.NullInt32) ([]GetTeamMembersRow, error) {
	rows, err := q.query(ctx, q.getTeamMembersStmt, getTeamMembers, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamMembersRow
	for rows.Next() {
		var i GetTeamMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Role,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamSolves = `-- name: GetTeamSolves :many
SELECT challenges.id, challenges.name, challenges.category, submissions.timestamp
  FROM submissions
  JOIN users ON users.id = submissions.user_id
  JOIN teams ON users.team_id = teams.id
  JOIN challenges ON challenges.id = submissions.chall_id
  WHERE users.role = 'Player'
    AND teams.id = $1
    AND submissions.status = 'Correct'
  ORDER BY submissions.timestamp DESC
`

type GetTeamSolvesRow struct {
	ID        int32     `json:"id"`
	Name      string    `json:"name"`
	Category  string    `json:"category"`
	Timestamp time.Time `json:"timestamp"`
}

// Retrieve all challenges solved by a team's members
func (q *Queries) GetTeamSolves(ctx context.Context, id int32) ([]GetTeamSolvesRow, error) {
	rows, err := q.query(ctx, q.getTeamSolvesStmt, getTeamSolves, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamSolvesRow
	for rows.Next() {
		var i GetTeamSolvesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Category,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamsPreview = `-- name: GetTeamsPreview :many
SELECT id, name, score, country, image
  FROM teams
  ORDER BY id
`

type GetTeamsPreviewRow struct {
	ID      int32          `json:"id"`
	Name    string         `json:"name"`
	Score   int32          `json:"score"`
	Country sql.NullString `json:"country"`
	Image   sql.NullString `json:"image"`
}

// Retrieve all teams
func (q *Queries) GetTeamsPreview(ctx context.Context) ([]GetTeamsPreviewRow, error) {
	rows, err := q.query(ctx, q.getTeamsPreviewStmt, getTeamsPreview)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamsPreviewRow
	for rows.Next() {
		var i GetTeamsPreviewRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Score,
			&i.Country,
			&i.Image,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, name, email, password_hash, created_at, score, role, team_id, country, image FROM users WHERE email = $1
`

// Retrieve a user by their email address
func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.queryRow(ctx, q.getUserByEmailStmt, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.Score,
		&i.Role,
		&i.TeamID,
		&i.Country,
		&i.Image,
	)
	return i, err
}

const getUserSolves = `-- name: GetUserSolves :many
SELECT s.chall_id, s.timestamp FROM submissions s
    WHERE s.user_id = $1
      AND s.status = 'Correct'
`

type GetUserSolvesRow struct {
	ChallID   int32     `json:"chall_id"`
	Timestamp time.Time `json:"timestamp"`
}

// Retrieve all challenges solved by a user
func (q *Queries) GetUserSolves(ctx context.Context, userID int32) ([]GetUserSolvesRow, error) {
	rows, err := q.query(ctx, q.getUserSolvesStmt, getUserSolves, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserSolvesRow
	for rows.Next() {
		var i GetUserSolvesRow
		if err := rows.Scan(&i.ChallID, &i.Timestamp); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersPreview = `-- name: GetUsersPreview :many
SELECT id, name, email, role, score, country, image
  FROM users
  ORDER BY id ASC
`

type GetUsersPreviewRow struct {
	ID      int32          `json:"id"`
	Name    string         `json:"name"`
	Email   string         `json:"email"`
	Role    UserRole       `json:"role"`
	Score   int32          `json:"score"`
	Country sql.NullString `json:"country"`
	Image   sql.NullString `json:"image"`
}

// Retrieve all users
func (q *Queries) GetUsersPreview(ctx context.Context) ([]GetUsersPreviewRow, error) {
	rows, err := q.query(ctx, q.getUsersPreviewStmt, getUsersPreview)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersPreviewRow
	for rows.Next() {
		var i GetUsersPreviewRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Role,
			&i.Score,
			&i.Country,
			&i.Image,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isChallengeSolved = `-- name: IsChallengeSolved :one
SELECT EXISTS(
  SELECT 1
    FROM submissions
    JOIN users ON users.id = submissions.user_id
    JOIN teams ON users.team_id = teams.id
      AND teams.id = (SELECT team_id FROM users WHERE users.id = $2)
    WHERE users.role = 'Player'
      AND submissions.status = 'Correct'
      AND submissions.chall_id = $1
)
`

type IsChallengeSolvedParams struct {
	ChallID int32 `json:"chall_id"`
	ID      int32 `json:"id"`
}

// Check if a challenge is solved by a user's team
func (q *Queries) IsChallengeSolved(ctx context.Context, arg IsChallengeSolvedParams) (bool, error) {
	row := q.queryRow(ctx, q.isChallengeSolvedStmt, isChallengeSolved, arg.ChallID, arg.ID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const registerTeam = `-- name: RegisterTeam :exec
WITH locked_user AS (
    SELECT id FROM users
    WHERE id = $1 AND team_id IS NULL
    FOR UPDATE
  ),
  new_team AS (
    INSERT INTO teams (name, password_hash)
    SELECT $2, $3
    FROM locked_user
    RETURNING id, name, password_hash, score, country, image, bio
  )
UPDATE users
  SET team_id = new_team.id
  FROM new_team
  WHERE users.id = $1
`

type RegisterTeamParams struct {
	ID           int32  `json:"id"`
	Name         string `json:"name"`
	PasswordHash string `json:"password_hash"`
}

// Insert a new team and add the founder user to the team
func (q *Queries) RegisterTeam(ctx context.Context, arg RegisterTeamParams) error {
	_, err := q.exec(ctx, q.registerTeamStmt, registerTeam, arg.ID, arg.Name, arg.PasswordHash)
	return err
}

const registerUser = `-- name: RegisterUser :one
INSERT INTO users (name, email, password_hash, role) VALUES ($1, $2, $3, $4) RETURNING id, name, email, password_hash, created_at, score, role, team_id, country, image
`

type RegisterUserParams struct {
	Name         string   `json:"name"`
	Email        string   `json:"email"`
	PasswordHash string   `json:"password_hash"`
	Role         UserRole `json:"role"`
}

// Insert a new user and return the created user
func (q *Queries) RegisterUser(ctx context.Context, arg RegisterUserParams) (User, error) {
	row := q.queryRow(ctx, q.registerUserStmt, registerUser,
		arg.Name,
		arg.Email,
		arg.PasswordHash,
		arg.Role,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.Score,
		&i.Role,
		&i.TeamID,
		&i.Country,
		&i.Image,
	)
	return i, err
}

const resetTeamPassword = `-- name: ResetTeamPassword :exec
UPDATE teams SET password_hash = $1 WHERE id = $2
`

type ResetTeamPasswordParams struct {
	PasswordHash string `json:"password_hash"`
	ID           int32  `json:"id"`
}

// Reset a team's password to a new password
func (q *Queries) ResetTeamPassword(ctx context.Context, arg ResetTeamPasswordParams) error {
	_, err := q.exec(ctx, q.resetTeamPasswordStmt, resetTeamPassword, arg.PasswordHash, arg.ID)
	return err
}

const resetUserPassword = `-- name: ResetUserPassword :exec
UPDATE users SET password_hash = $1 WHERE id = $2
`

type ResetUserPasswordParams struct {
	PasswordHash string `json:"password_hash"`
	ID           int32  `json:"id"`
}

// Reset a user's password to a new password
func (q *Queries) ResetUserPassword(ctx context.Context, arg ResetUserPasswordParams) error {
	_, err := q.exec(ctx, q.resetUserPasswordStmt, resetUserPassword, arg.PasswordHash, arg.ID)
	return err
}

const submit = `-- name: Submit :one
INSERT INTO submissions (user_id, chall_id, status, flag) VALUES ($1, $2, $3, $4) RETURNING status
`

type SubmitParams struct {
	UserID  int32            `json:"user_id"`
	ChallID int32            `json:"chall_id"`
	Status  SubmissionStatus `json:"status"`
	Flag    string           `json:"flag"`
}

// Insert a new submission
func (q *Queries) Submit(ctx context.Context, arg SubmitParams) (SubmissionStatus, error) {
	row := q.queryRow(ctx, q.submitStmt, submit,
		arg.UserID,
		arg.ChallID,
		arg.Status,
		arg.Flag,
	)
	var status SubmissionStatus
	err := row.Scan(&status)
	return status, err
}

const updateTeam = `-- name: UpdateTeam :exec
UPDATE teams
SET
  country = COALESCE($2, country),
  image = COALESCE($3, image),
  bio = COALESCE($4, bio)
WHERE id = $1
`

type UpdateTeamParams struct {
	ID      int32          `json:"id"`
	Country sql.NullString `json:"country"`
	Image   sql.NullString `json:"image"`
	Bio     sql.NullString `json:"bio"`
}

// Update team details
func (q *Queries) UpdateTeam(ctx context.Context, arg UpdateTeamParams) error {
	_, err := q.exec(ctx, q.updateTeamStmt, updateTeam,
		arg.ID,
		arg.Country,
		arg.Image,
		arg.Bio,
	)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
SET
  name = COALESCE($2, name),
  country = COALESCE($3, country),
  image = COALESCE($4, image)
WHERE id = $1
`

type UpdateUserParams struct {
	ID      int32          `json:"id"`
	Name    sql.NullString `json:"name"`
	Country sql.NullString `json:"country"`
	Image   sql.NullString `json:"image"`
}

// Update user details
func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.exec(ctx, q.updateUserStmt, updateUser,
		arg.ID,
		arg.Name,
		arg.Country,
		arg.Image,
	)
	return err
}
