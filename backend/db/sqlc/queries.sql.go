// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const addTeamMember = `-- name: AddTeamMember :exec
UPDATE users SET team_id = $1 WHERE id = $2 AND team_id IS NULL
`

type AddTeamMemberParams struct {
	TeamID sql.NullInt32 `json:"team_id"`
	ID     int32         `json:"id"`
}

// Assign a user to a team
func (q *Queries) AddTeamMember(ctx context.Context, arg AddTeamMemberParams) error {
	_, err := q.exec(ctx, q.addTeamMemberStmt, addTeamMember, arg.TeamID, arg.ID)
	return err
}

const checkFlags = `-- name: CheckFlags :one
SELECT BOOL_OR(($1 = flag) OR (regex AND $1 ~ flag)) FROM flags WHERE chall_id = $2
`

type CheckFlagsParams struct {
	Flag    string `json:"flag"`
	ChallID int32  `json:"chall_id"`
}

// Check if a flag matches any flags for a challenge
func (q *Queries) CheckFlags(ctx context.Context, arg CheckFlagsParams) (bool, error) {
	row := q.queryRow(ctx, q.checkFlagsStmt, checkFlags, arg.Flag, arg.ChallID)
	var bool_or bool
	err := row.Scan(&bool_or)
	return bool_or, err
}

const createCategory = `-- name: CreateCategory :exec
INSERT INTO categories (name, icon) VALUES ($1, $2)
`

type CreateCategoryParams struct {
	Name string `json:"name"`
	Icon string `json:"icon"`
}

// Insert a new category
func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) error {
	_, err := q.exec(ctx, q.createCategoryStmt, createCategory, arg.Name, arg.Icon)
	return err
}

const createChallenge = `-- name: CreateChallenge :one
INSERT INTO challenges (name, category, description, type, max_points, score_type)
  VALUES ($1, $2, $3, $4, $5, $6) RETURNING id
`

type CreateChallengeParams struct {
	Name        string     `json:"name"`
	Category    string     `json:"category"`
	Description string     `json:"description"`
	Type        DeployType `json:"type"`
	MaxPoints   int32      `json:"max_points"`
	ScoreType   ScoreType  `json:"score_type"`
}

// Insert a new challenge
func (q *Queries) CreateChallenge(ctx context.Context, arg CreateChallengeParams) (int32, error) {
	row := q.queryRow(ctx, q.createChallengeStmt, createChallenge,
		arg.Name,
		arg.Category,
		arg.Description,
		arg.Type,
		arg.MaxPoints,
		arg.ScoreType,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createFlag = `-- name: CreateFlag :exec
INSERT INTO flags (flag, chall_id, regex) VALUES ($1, $2, $3)
`

type CreateFlagParams struct {
	Flag    string `json:"flag"`
	ChallID int32  `json:"chall_id"`
	Regex   bool   `json:"regex"`
}

// Insert a new flag for a challenge
func (q *Queries) CreateFlag(ctx context.Context, arg CreateFlagParams) error {
	_, err := q.exec(ctx, q.createFlagStmt, createFlag, arg.Flag, arg.ChallID, arg.Regex)
	return err
}

const createTag = `-- name: CreateTag :exec
INSERT INTO tags (chall_id, name) VALUES ($1, $2)
`

type CreateTagParams struct {
	ChallID int32  `json:"chall_id"`
	Name    string `json:"name"`
}

// Creates a named tag for a challenge
func (q *Queries) CreateTag(ctx context.Context, arg CreateTagParams) error {
	_, err := q.exec(ctx, q.createTagStmt, createTag, arg.ChallID, arg.Name)
	return err
}

const deleteCategory = `-- name: DeleteCategory :exec
DELETE FROM categories WHERE name = $1
`

// Delete a category and all associated challenges
func (q *Queries) DeleteCategory(ctx context.Context, name string) error {
	_, err := q.exec(ctx, q.deleteCategoryStmt, deleteCategory, name)
	return err
}

const deleteChallenge = `-- name: DeleteChallenge :exec
DELETE FROM challenges WHERE id = $1
`

// Delete a challenge and all associated flags
func (q *Queries) DeleteChallenge(ctx context.Context, id int32) error {
	_, err := q.exec(ctx, q.deleteChallengeStmt, deleteChallenge, id)
	return err
}

const deleteFlag = `-- name: DeleteFlag :exec
DELETE FROM flags WHERE chall_id = $1 AND flag = $2
`

type DeleteFlagParams struct {
	ChallID int32  `json:"chall_id"`
	Flag    string `json:"flag"`
}

// Delete a flag from a challenge
func (q *Queries) DeleteFlag(ctx context.Context, arg DeleteFlagParams) error {
	_, err := q.exec(ctx, q.deleteFlagStmt, deleteFlag, arg.ChallID, arg.Flag)
	return err
}

const deleteTag = `-- name: DeleteTag :exec
DELETE FROM tags WHERE chall_id = $1 AND name = $2
`

type DeleteTagParams struct {
	ChallID int32  `json:"chall_id"`
	Name    string `json:"name"`
}

// Deletes a challenge tag by name
func (q *Queries) DeleteTag(ctx context.Context, arg DeleteTagParams) error {
	_, err := q.exec(ctx, q.deleteTagStmt, deleteTag, arg.ChallID, arg.Name)
	return err
}

const getCategory = `-- name: GetCategory :one
SELECT name, visible_challs, icon FROM categories WHERE name = $1
`

// fetch category by name
func (q *Queries) GetCategory(ctx context.Context, name string) (Category, error) {
	row := q.queryRow(ctx, q.getCategoryStmt, getCategory, name)
	var i Category
	err := row.Scan(&i.Name, &i.VisibleChalls, &i.Icon)
	return i, err
}

const getChallDockerConfig = `-- name: GetChallDockerConfig :one
SELECT chall_id, image, compose, hash_domain, lifetime, envs, max_memory, max_cpu FROM docker_configs WHERE chall_id = $1
`

func (q *Queries) GetChallDockerConfig(ctx context.Context, challID int32) (DockerConfig, error) {
	row := q.queryRow(ctx, q.getChallDockerConfigStmt, getChallDockerConfig, challID)
	var i DockerConfig
	err := row.Scan(
		&i.ChallID,
		&i.Image,
		&i.Compose,
		&i.HashDomain,
		&i.Lifetime,
		&i.Envs,
		&i.MaxMemory,
		&i.MaxCpu,
	)
	return i, err
}

const getChallengeSolves = `-- name: GetChallengeSolves :many
SELECT teams.id, teams.name, submissions.timestamp
  FROM submissions
  JOIN users ON users.id = submissions.user_id
  JOIN teams ON users.team_id = teams.id
  WHERE users.role = 'Player'
    AND submissions.chall_id = $1
    AND submissions.status = 'Correct'
  ORDER BY submissions.timestamp ASC
`

type GetChallengeSolvesRow struct {
	ID        int32     `json:"id"`
	Name      string    `json:"name"`
	Timestamp time.Time `json:"timestamp"`
}

// Retrieve all teams that solved a challenge
func (q *Queries) GetChallengeSolves(ctx context.Context, challID int32) ([]GetChallengeSolvesRow, error) {
	rows, err := q.query(ctx, q.getChallengeSolvesStmt, getChallengeSolves, challID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChallengeSolvesRow
	for rows.Next() {
		var i GetChallengeSolvesRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Timestamp); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChallengesPreview = `-- name: GetChallengesPreview :many
SELECT id, name, category, difficulty, type, hidden, points, solves, EXISTS(
  SELECT 1
    FROM submissions
    JOIN users ON users.id = submissions.user_id
    JOIN teams ON users.team_id = teams.id
      AND teams.id = (SELECT team_id FROM users WHERE users.id = $1)
    WHERE users.role = 'Player'
      AND submissions.status = 'Correct'
      AND submissions.chall_id = challenges.id) AS solved
  FROM challenges
`

type GetChallengesPreviewRow struct {
	ID         int32          `json:"id"`
	Name       string         `json:"name"`
	Category   string         `json:"category"`
	Difficulty sql.NullString `json:"difficulty"`
	Type       DeployType     `json:"type"`
	Hidden     bool           `json:"hidden"`
	Points     int32          `json:"points"`
	Solves     int32          `json:"solves"`
	Solved     bool           `json:"solved"`
}

// Retrieve all challenges
func (q *Queries) GetChallengesPreview(ctx context.Context, id int32) ([]GetChallengesPreviewRow, error) {
	rows, err := q.query(ctx, q.getChallengesPreviewStmt, getChallengesPreview, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChallengesPreviewRow
	for rows.Next() {
		var i GetChallengesPreviewRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Category,
			&i.Difficulty,
			&i.Type,
			&i.Hidden,
			&i.Points,
			&i.Solves,
			&i.Solved,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFirstBlood = `-- name: GetFirstBlood :one
SELECT teams.id, teams.name
  FROM submissions
  JOIN users ON users.id = submissions.user_id
  JOIN teams ON users.team_id = teams.id
  WHERE users.role = 'Player'
    AND submissions.chall_id = $1
    AND submissions.status = 'Correct'
  ORDER BY submissions.timestamp ASC
  LIMIT 1
`

type GetFirstBloodRow struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
}

// Retrieve the team that achieved the first blood on a challenge
func (q *Queries) GetFirstBlood(ctx context.Context, challID int32) (GetFirstBloodRow, error) {
	row := q.queryRow(ctx, q.getFirstBloodStmt, getFirstBlood, challID)
	var i GetFirstBloodRow
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const getFlagsByChallenge = `-- name: GetFlagsByChallenge :many
SELECT flag, regex FROM flags WHERE chall_id = $1
`

type GetFlagsByChallengeRow struct {
	Flag  string `json:"flag"`
	Regex bool   `json:"regex"`
}

// Retrieve all flags associated with a challenge
func (q *Queries) GetFlagsByChallenge(ctx context.Context, challID int32) ([]GetFlagsByChallengeRow, error) {
	rows, err := q.query(ctx, q.getFlagsByChallengeStmt, getFlagsByChallenge, challID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFlagsByChallengeRow
	for rows.Next() {
		var i GetFlagsByChallengeRow
		if err := rows.Scan(&i.Flag, &i.Regex); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamMembers = `-- name: GetTeamMembers :many
SELECT id, name, role, score FROM users WHERE team_id = $1 ORDER BY id
`

type GetTeamMembersRow struct {
	ID    int32    `json:"id"`
	Name  string   `json:"name"`
	Role  UserRole `json:"role"`
	Score int32    `json:"score"`
}

// Retrieve all members of a team by team ID
func (q *Queries) GetTeamMembers(ctx context.Context, teamID sql.NullInt32) ([]GetTeamMembersRow, error) {
	rows, err := q.query(ctx, q.getTeamMembersStmt, getTeamMembers, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamMembersRow
	for rows.Next() {
		var i GetTeamMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Role,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamSolves = `-- name: GetTeamSolves :many
SELECT challenges.id, challenges.name, challenges.category, submissions.timestamp
  FROM submissions
  JOIN users ON users.id = submissions.user_id
  JOIN teams ON users.team_id = teams.id
  JOIN challenges ON challenges.id = submissions.chall_id
  WHERE users.role = 'Player'
    AND teams.id = $1
    AND submissions.status = 'Correct'
  ORDER BY submissions.timestamp DESC
`

type GetTeamSolvesRow struct {
	ID        int32     `json:"id"`
	Name      string    `json:"name"`
	Category  string    `json:"category"`
	Timestamp time.Time `json:"timestamp"`
}

// Retrieve all challenges solved by a team's members
func (q *Queries) GetTeamSolves(ctx context.Context, id int32) ([]GetTeamSolvesRow, error) {
	rows, err := q.query(ctx, q.getTeamSolvesStmt, getTeamSolves, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamSolvesRow
	for rows.Next() {
		var i GetTeamSolvesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Category,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamsPreview = `-- name: GetTeamsPreview :many
SELECT id, name, score, country, image
  FROM teams
  ORDER BY id
`

type GetTeamsPreviewRow struct {
	ID      int32          `json:"id"`
	Name    string         `json:"name"`
	Score   int32          `json:"score"`
	Country sql.NullString `json:"country"`
	Image   sql.NullString `json:"image"`
}

// Retrieve all teams
func (q *Queries) GetTeamsPreview(ctx context.Context) ([]GetTeamsPreviewRow, error) {
	rows, err := q.query(ctx, q.getTeamsPreviewStmt, getTeamsPreview)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamsPreviewRow
	for rows.Next() {
		var i GetTeamsPreviewRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Score,
			&i.Country,
			&i.Image,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamsScoreboard = `-- name: GetTeamsScoreboard :many
SELECT id, name, score, country, image
  FROM teams
  ORDER BY score DESC
`

type GetTeamsScoreboardRow struct {
	ID      int32          `json:"id"`
	Name    string         `json:"name"`
	Score   int32          `json:"score"`
	Country sql.NullString `json:"country"`
	Image   sql.NullString `json:"image"`
}

// Retrieve all teams
func (q *Queries) GetTeamsScoreboard(ctx context.Context) ([]GetTeamsScoreboardRow, error) {
	rows, err := q.query(ctx, q.getTeamsScoreboardStmt, getTeamsScoreboard)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamsScoreboardRow
	for rows.Next() {
		var i GetTeamsScoreboardRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Score,
			&i.Country,
			&i.Image,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, name, email, password_hash, created_at, score, role, team_id, country, image FROM users WHERE email = $1
`

// Retrieve a user by their email address
func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.queryRow(ctx, q.getUserByEmailStmt, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.Score,
		&i.Role,
		&i.TeamID,
		&i.Country,
		&i.Image,
	)
	return i, err
}

const getUserSolves = `-- name: GetUserSolves :many
SELECT s.chall_id, s.timestamp FROM submissions s
    WHERE s.user_id = $1
      AND s.status = 'Correct'
`

type GetUserSolvesRow struct {
	ChallID   int32     `json:"chall_id"`
	Timestamp time.Time `json:"timestamp"`
}

// Retrieve all challenges solved by a user
func (q *Queries) GetUserSolves(ctx context.Context, userID int32) ([]GetUserSolvesRow, error) {
	rows, err := q.query(ctx, q.getUserSolvesStmt, getUserSolves, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserSolvesRow
	for rows.Next() {
		var i GetUserSolvesRow
		if err := rows.Scan(&i.ChallID, &i.Timestamp); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersPreview = `-- name: GetUsersPreview :many
SELECT id, name, email, role, score, country, image
  FROM users
  ORDER BY id ASC
`

type GetUsersPreviewRow struct {
	ID      int32          `json:"id"`
	Name    string         `json:"name"`
	Email   string         `json:"email"`
	Role    UserRole       `json:"role"`
	Score   int32          `json:"score"`
	Country sql.NullString `json:"country"`
	Image   sql.NullString `json:"image"`
}

// Retrieve all users
func (q *Queries) GetUsersPreview(ctx context.Context) ([]GetUsersPreviewRow, error) {
	rows, err := q.query(ctx, q.getUsersPreviewStmt, getUsersPreview)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersPreviewRow
	for rows.Next() {
		var i GetUsersPreviewRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Role,
			&i.Score,
			&i.Country,
			&i.Image,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isChallengeSolved = `-- name: IsChallengeSolved :one
SELECT EXISTS(
  SELECT 1
    FROM submissions
    JOIN users ON users.id = submissions.user_id
    JOIN teams ON users.team_id = teams.id
      AND teams.id = (SELECT team_id FROM users WHERE users.id = $2)
    WHERE users.role = 'Player'
      AND submissions.status = 'Correct'
      AND submissions.chall_id = $1
)
`

type IsChallengeSolvedParams struct {
	ChallID int32 `json:"chall_id"`
	ID      int32 `json:"id"`
}

// Check if a challenge is solved by a user's team
func (q *Queries) IsChallengeSolved(ctx context.Context, arg IsChallengeSolvedParams) (bool, error) {
	row := q.queryRow(ctx, q.isChallengeSolvedStmt, isChallengeSolved, arg.ChallID, arg.ID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const registerTeam = `-- name: RegisterTeam :exec
WITH locked_user AS (
    SELECT id FROM users
    WHERE id = $1 AND team_id IS NULL
    FOR UPDATE
  ),
  new_team AS (
    INSERT INTO teams (name, password_hash)
    SELECT $2, $3
    FROM locked_user
    RETURNING id, name, password_hash, score, country, image, bio
  )
UPDATE users
  SET team_id = new_team.id
  FROM new_team
  WHERE users.id = $1
`

type RegisterTeamParams struct {
	ID           int32  `json:"id"`
	Name         string `json:"name"`
	PasswordHash string `json:"password_hash"`
}

// Insert a new team and add the founder user to the team
func (q *Queries) RegisterTeam(ctx context.Context, arg RegisterTeamParams) error {
	_, err := q.exec(ctx, q.registerTeamStmt, registerTeam, arg.ID, arg.Name, arg.PasswordHash)
	return err
}

const registerUser = `-- name: RegisterUser :one
INSERT INTO users (name, email, password_hash, role) VALUES ($1, $2, $3, $4) RETURNING id, name, email, password_hash, created_at, score, role, team_id, country, image
`

type RegisterUserParams struct {
	Name         string   `json:"name"`
	Email        string   `json:"email"`
	PasswordHash string   `json:"password_hash"`
	Role         UserRole `json:"role"`
}

// Insert a new user and return the created user
func (q *Queries) RegisterUser(ctx context.Context, arg RegisterUserParams) (User, error) {
	row := q.queryRow(ctx, q.registerUserStmt, registerUser,
		arg.Name,
		arg.Email,
		arg.PasswordHash,
		arg.Role,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.CreatedAt,
		&i.Score,
		&i.Role,
		&i.TeamID,
		&i.Country,
		&i.Image,
	)
	return i, err
}

const resetTeamPassword = `-- name: ResetTeamPassword :exec
UPDATE teams SET password_hash = $1 WHERE id = $2
`

type ResetTeamPasswordParams struct {
	PasswordHash string `json:"password_hash"`
	ID           int32  `json:"id"`
}

// Reset a team's password to a new password
func (q *Queries) ResetTeamPassword(ctx context.Context, arg ResetTeamPasswordParams) error {
	_, err := q.exec(ctx, q.resetTeamPasswordStmt, resetTeamPassword, arg.PasswordHash, arg.ID)
	return err
}

const resetUserPassword = `-- name: ResetUserPassword :exec
UPDATE users SET password_hash = $1 WHERE id = $2
`

type ResetUserPasswordParams struct {
	PasswordHash string `json:"password_hash"`
	ID           int32  `json:"id"`
}

// Reset a user's password to a new password
func (q *Queries) ResetUserPassword(ctx context.Context, arg ResetUserPasswordParams) error {
	_, err := q.exec(ctx, q.resetUserPasswordStmt, resetUserPassword, arg.PasswordHash, arg.ID)
	return err
}

const submit = `-- name: Submit :one
WITH challenge AS (
    SELECT challenges.id FROM challenges
    WHERE challenges.id = $2 FOR UPDATE
  ),
  inserted AS (
    INSERT INTO submissions (user_id, chall_id, status, flag)
    VALUES ($1, (SELECT id FROM challenge), $4, $3)
    RETURNING status
  ),
  blood_check AS (
    SELECT COUNT(*)=0 AS first_blood FROM submissions
    WHERE chall_id = (SELECT id FROM challenge) AND status = 'Correct'
  )
SELECT inserted.status, (blood_check.first_blood AND ($4 = 'Correct')) AS first_blood FROM inserted, blood_check
`

type SubmitParams struct {
	UserID int32       `json:"user_id"`
	ID     int32       `json:"id"`
	Flag   string      `json:"flag"`
	Status interface{} `json:"status"`
}

type SubmitRow struct {
	Status     SubmissionStatus `json:"status"`
	FirstBlood sql.NullBool     `json:"first_blood"`
}

// Insert a new submission
func (q *Queries) Submit(ctx context.Context, arg SubmitParams) (SubmitRow, error) {
	row := q.queryRow(ctx, q.submitStmt, submit,
		arg.UserID,
		arg.ID,
		arg.Flag,
		arg.Status,
	)
	var i SubmitRow
	err := row.Scan(&i.Status, &i.FirstBlood)
	return i, err
}

const updateCategoryIcon = `-- name: UpdateCategoryIcon :exec
UPDATE categories SET icon = $2 WHERE name = $1
`

type UpdateCategoryIconParams struct {
	Name string `json:"name"`
	Icon string `json:"icon"`
}

// update category icon by name
func (q *Queries) UpdateCategoryIcon(ctx context.Context, arg UpdateCategoryIconParams) error {
	_, err := q.exec(ctx, q.updateCategoryIconStmt, updateCategoryIcon, arg.Name, arg.Icon)
	return err
}

const updateChallenge = `-- name: UpdateChallenge :exec
UPDATE challenges
SET
  name = COALESCE($1, name),
  category = COALESCE($2, category),
  description = COALESCE($3, description),
  difficulty = COALESCE($4, difficulty),
  authors = COALESCE($5, authors),
  type = COALESCE($6, type),
  hidden = COALESCE($7, hidden),
  max_points = COALESCE($8, max_points),
  score_type = COALESCE($9, score_type),
  host = COALESCE($10, host),
  port = COALESCE($11, port),
  attachments = COALESCE($12, attachments)
WHERE id = $13
`

type UpdateChallengeParams struct {
	Name        sql.NullString `json:"name"`
	Category    sql.NullString `json:"category"`
	Description sql.NullString `json:"description"`
	Difficulty  sql.NullString `json:"difficulty"`
	Authors     sql.NullString `json:"authors"`
	Type        NullDeployType `json:"type"`
	Hidden      sql.NullBool   `json:"hidden"`
	MaxPoints   sql.NullInt32  `json:"max_points"`
	ScoreType   NullScoreType  `json:"score_type"`
	Host        sql.NullString `json:"host"`
	Port        sql.NullInt32  `json:"port"`
	Attachments sql.NullString `json:"attachments"`
	ChallID     int32          `json:"chall_id"`
}

// Updates the challenge with the given ID
func (q *Queries) UpdateChallenge(ctx context.Context, arg UpdateChallengeParams) error {
	_, err := q.exec(ctx, q.updateChallengeStmt, updateChallenge,
		arg.Name,
		arg.Category,
		arg.Description,
		arg.Difficulty,
		arg.Authors,
		arg.Type,
		arg.Hidden,
		arg.MaxPoints,
		arg.ScoreType,
		arg.Host,
		arg.Port,
		arg.Attachments,
		arg.ChallID,
	)
	return err
}

const updateChallengesCategory = `-- name: UpdateChallengesCategory :exec
UPDATE challenges SET category = $1 WHERE category = $2
`

type UpdateChallengesCategoryParams struct {
	NewCategory string `json:"new_category"`
	OldCategory string `json:"old_category"`
}

// update category name in challenges table
func (q *Queries) UpdateChallengesCategory(ctx context.Context, arg UpdateChallengesCategoryParams) error {
	_, err := q.exec(ctx, q.updateChallengesCategoryStmt, updateChallengesCategory, arg.NewCategory, arg.OldCategory)
	return err
}

const updateDockerConfigs = `-- name: UpdateDockerConfigs :exec
UPDATE docker_configs
SET
  image = COALESCE($1, image),
  compose = COALESCE($2, compose),
  hash_domain = COALESCE($3, hash_domain),
  lifetime = COALESCE($4, lifetime),
  envs = COALESCE($5, envs),
  max_memory = COALESCE($6, max_memory),
  max_cpu = COALESCE($7, max_cpu)
WHERE chall_id = $8
`

type UpdateDockerConfigsParams struct {
	Image      sql.NullString `json:"image"`
	Compose    sql.NullString `json:"compose"`
	HashDomain sql.NullBool   `json:"hash_domain"`
	Lifetime   sql.NullInt32  `json:"lifetime"`
	Envs       sql.NullString `json:"envs"`
	MaxMemory  sql.NullInt32  `json:"max_memory"`
	MaxCpu     sql.NullString `json:"max_cpu"`
	ChallID    int32          `json:"chall_id"`
}

// Updates the Docker configurations for the challenge with the given ID
func (q *Queries) UpdateDockerConfigs(ctx context.Context, arg UpdateDockerConfigsParams) error {
	_, err := q.exec(ctx, q.updateDockerConfigsStmt, updateDockerConfigs,
		arg.Image,
		arg.Compose,
		arg.HashDomain,
		arg.Lifetime,
		arg.Envs,
		arg.MaxMemory,
		arg.MaxCpu,
		arg.ChallID,
	)
	return err
}

const updateFlag = `-- name: UpdateFlag :exec
UPDATE flags
  SET
    flag = COALESCE($3, flag),
    regex = COALESCE($4, regex)
  WHERE chall_id = $1
    AND flag = $2
`

type UpdateFlagParams struct {
	ChallID int32          `json:"chall_id"`
	Flag    string         `json:"flag"`
	NewFlag sql.NullString `json:"new_flag"`
	Regex   sql.NullBool   `json:"regex"`
}

func (q *Queries) UpdateFlag(ctx context.Context, arg UpdateFlagParams) error {
	_, err := q.exec(ctx, q.updateFlagStmt, updateFlag,
		arg.ChallID,
		arg.Flag,
		arg.NewFlag,
		arg.Regex,
	)
	return err
}

const updateTag = `-- name: UpdateTag :exec
UPDATE tags SET name = $2 WHERE chall_id = $1 AND name = $3
`

type UpdateTagParams struct {
	ChallID int32  `json:"chall_id"`
	NewName string `json:"new_name"`
	OldName string `json:"old_name"`
}

// Updates the name of a challenge tag
func (q *Queries) UpdateTag(ctx context.Context, arg UpdateTagParams) error {
	_, err := q.exec(ctx, q.updateTagStmt, updateTag, arg.ChallID, arg.NewName, arg.OldName)
	return err
}

const updateTeam = `-- name: UpdateTeam :exec
UPDATE teams
SET
  country = COALESCE($2, country),
  image = COALESCE($3, image),
  bio = COALESCE($4, bio)
WHERE id = $1
`

type UpdateTeamParams struct {
	ID      int32          `json:"id"`
	Country sql.NullString `json:"country"`
	Image   sql.NullString `json:"image"`
	Bio     sql.NullString `json:"bio"`
}

// Update team details
func (q *Queries) UpdateTeam(ctx context.Context, arg UpdateTeamParams) error {
	_, err := q.exec(ctx, q.updateTeamStmt, updateTeam,
		arg.ID,
		arg.Country,
		arg.Image,
		arg.Bio,
	)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
SET
  name = COALESCE($2, name),
  country = COALESCE($3, country),
  image = COALESCE($4, image)
WHERE id = $1
`

type UpdateUserParams struct {
	ID      int32          `json:"id"`
	Name    sql.NullString `json:"name"`
	Country sql.NullString `json:"country"`
	Image   sql.NullString `json:"image"`
}

// Update user details
func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.exec(ctx, q.updateUserStmt, updateUser,
		arg.ID,
		arg.Name,
		arg.Country,
		arg.Image,
	)
	return err
}
